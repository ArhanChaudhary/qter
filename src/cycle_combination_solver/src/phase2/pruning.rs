//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use super::puzzle::{PuzzleDef, PuzzleState};

// Trait declarations

pub trait PruningTables<'a, P: PuzzleState + 'a> {
    type GenerateMeta;

    fn generate(generate_meta: Self::GenerateMeta) -> Self;
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

/// A trait for a storage backend that can be used to store the pruning tables.
/// We only define a getter (despite looking strange) because there is always
/// only one way to get a value from the storage backend, while there are
/// multiple ways to set a value. The setter is defined in
/// `InnterOrbitPruningTable` and this technique minimizes code duplication
/// while ensuring fast runtime.
pub trait StorageBackend<const EXACT: bool> {
    fn permissible_heuristic_hash(&self, hash: u64) -> u8;
    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic);
}

/// An "outer" pruning table trait that is supposed to be implemented on a generic
/// storage backend newtype. Defines shared behavior for all specialized
/// type state implementations of the orbit pruning table.
trait OuterOrbitPruningTable<P: PuzzleState> {
    fn hash_puzzle_state(&self, puzzle_state: &P, puzzle_def: &PuzzleDef<P>) -> u64;

    /// Implementors are expected to forward the call to their storage backend.
    /// Interestingly, the alternative way of requiring a storage backend getter
    /// needs a trait object which is slow so this seems to be the best way.
    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8;

    /// This convenience function is a performance optimization that avoids two
    /// otherwise dynamic dispatches.
    fn permissible_heuristic(&self, puzzle_state: &P, puzzle_def: &PuzzleDef<P>) -> u8 {
        self.permissible_heuristic_hash_outer(self.hash_puzzle_state(puzzle_state, puzzle_def))
    }
}

/// An "inner" pruning table trait that is supposed to be implemented on
/// specialized type state implementations of the orbit pruning table.
trait InnerOrbitPruningTable<P: PuzzleState>: OuterOrbitPruningTable<P> {
    /// Generates a new pruning table for the given orbit index and maximum size.
    /// Returns the pruning table and the size used in bytes.
    fn generate(puzzle_def: &PuzzleDef<P>, orbit_index: usize, max_size: u64) -> (Self, u64)
    where
        Self: Sized;
}

// Data structure declarations

struct OrbitPruningTables<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    // Inner implies outer
    orbit_pruning_tables: Box<[Box<dyn InnerOrbitPruningTable<P>>]>,
}

pub struct OrbitPruningTablesGenerateMeta<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    max_size: u64,
    // field to force specific tables (for tests)?
}

pub struct UncompressedStorageBackend {
    data: Box<[OrbitPruneHeuristic]>,
    depth_traversed: u8,
}

struct TANSStorageEncodingTable {
    // silly things here
}

pub struct TANSStorageBackend {
    data: Box<[OrbitPruneHeuristic]>,
    counts_by_depth: Box<[u64]>,
    encoding_tables: Box<[TANSStorageEncodingTable]>,
}

/// This type isn't actually entirely useless; I will use it for tables that
/// have no remaining allocable space (by the max_size option).
pub struct ZeroStorageBackend;

pub struct ApproximatePruningTable<S: StorageBackend<false>> {
    storage_backend: S,
    orbit_index: usize,
}

pub struct ExactPruningTable<S: StorageBackend<true>> {
    storage_backend: S,
    orbit_index: usize,
}

pub struct CycleTypePruningTable<S: StorageBackend<true>> {
    storage_backend: S,
    orbit_index: usize,
}

pub struct ZeroTable<P: PuzzleState>(std::marker::PhantomData<P>);

// Implementations

use private::OrbitPruneHeuristic;
mod private {
    #[derive(Clone, PartialOrd, Ord, PartialEq, Eq)]
    #[repr(transparent)]
    pub struct OrbitPruneHeuristic(u8);

    impl OrbitPruneHeuristic {
        const VACANT: u8 = u8::MAX;

        pub fn vacant() -> OrbitPruneHeuristic {
            OrbitPruneHeuristic(Self::VACANT)
        }

        pub fn occupied(depth_traversed: u8) -> Option<OrbitPruneHeuristic> {
            if depth_traversed == Self::VACANT {
                None
            } else {
                Some(OrbitPruneHeuristic(depth_traversed))
            }
        }

        pub fn is_vacant(&self) -> bool {
            self.0 == Self::VACANT
        }

        pub fn get_occupied(&self) -> Option<u8> {
            if self.is_vacant() { None } else { Some(self.0) }
        }
    }
}

impl<'a, P: PuzzleState> PruningTables<'a, P> for OrbitPruningTables<'a, P> {
    type GenerateMeta = OrbitPruningTablesGenerateMeta<'a, P>;

    fn generate(generate_meta: OrbitPruningTablesGenerateMeta<P>) -> OrbitPruningTables<P> {
        let mut orbit_pruning_tables = vec![];
        let mut remaining_size = generate_meta.max_size;
        // Already sorted by (piece count, orientation) which is (usually) from
        // smallest to largest which makes this work. This essentially populates
        // the smallest pruning tables while dynamically updating how much space
        // is reserved for the remaining orbit tables.
        for orbit_index in 0..generate_meta.puzzle_def.sorted_orbit_defs.len() {
            let unprocessed_orbits_count =
                generate_meta.puzzle_def.sorted_orbit_defs.len() - orbit_index;
            let (orbit_pruning_table, used_size) = choose_pruning_table(
                generate_meta.puzzle_def,
                orbit_index,
                remaining_size / unprocessed_orbits_count as u64,
            );
            remaining_size -= used_size;
            orbit_pruning_tables.push(orbit_pruning_table);
        }

        OrbitPruningTables {
            puzzle_def: generate_meta.puzzle_def,
            orbit_pruning_tables: orbit_pruning_tables.into_boxed_slice(),
        }
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.orbit_pruning_tables
            .iter()
            .fold(0, |best_bound, orbit_pruning_table| {
                best_bound
                    .max(orbit_pruning_table.permissible_heuristic(puzzle_state, self.puzzle_def))
            })
    }
}

/// Choose the appropriate pruning table based on the orbit definition and size.
/// Returns a pruning table trait object along with its size in bytes.
fn choose_pruning_table<P: PuzzleState>(
    puzzle_def: &PuzzleDef<P>,
    orbit_index: usize,
    max_size: u64,
) -> (Box<dyn InnerOrbitPruningTable<P>>, u64) {
    // I tried using a generic function but rust just geeked out
    macro_rules! generate_pruning_table {
        ($table:ty) => {{
            let (table, used_size) = <$table>::generate(puzzle_def, orbit_index, max_size);
            (Box::new(table), used_size)
        }};
    }

    todo!();
}

impl<const EXACT: bool> StorageBackend<EXACT> for UncompressedStorageBackend {
    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        self.data[hash as usize]
            .get_occupied()
            .unwrap_or(self.depth_traversed)
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            self.data[hash as usize] = orbit_prune_heuristic;
        } else {
            self.data[hash as usize] = self.data[hash as usize].clone().min(orbit_prune_heuristic);
        }
    }
}

impl<const EXACT: bool> StorageBackend<EXACT> for TANSStorageBackend {
    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }
}

impl StorageBackend<true> for ZeroStorageBackend {
    fn permissible_heuristic_hash(&self, _hash: u64) -> u8 {
        0
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {}
}

impl<P: PuzzleState, S: StorageBackend<false>> OuterOrbitPruningTable<P>
    for ApproximatePruningTable<S>
{
    fn hash_puzzle_state(&self, puzzle_state: &P, puzzle_def: &PuzzleDef<P>) -> u64 {
        fxhash::hash64(
            &puzzle_state.orbit_bytes_by_index(self.orbit_index, &puzzle_def.sorted_orbit_defs),
        )
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<P: PuzzleState, S: StorageBackend<true>> OuterOrbitPruningTable<P> for ExactPruningTable<S> {
    fn hash_puzzle_state(&self, puzzle_state: &P, puzzle_def: &PuzzleDef<P>) -> u64 {
        todo!();
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<P: PuzzleState, S: StorageBackend<true>> OuterOrbitPruningTable<P>
    for CycleTypePruningTable<S>
{
    fn hash_puzzle_state(&self, puzzle_state: &P, puzzle_def: &PuzzleDef<P>) -> u64 {
        todo!();
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<P: PuzzleState> InnerOrbitPruningTable<P>
    for ApproximatePruningTable<UncompressedStorageBackend>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size: u64,
    ) -> (ApproximatePruningTable<UncompressedStorageBackend>, u64) {
        todo!();
    }
}

impl<P: PuzzleState> InnerOrbitPruningTable<P> for ApproximatePruningTable<TANSStorageBackend> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size: u64,
    ) -> (ApproximatePruningTable<TANSStorageBackend>, u64) {
        todo!();
    }
}

impl<P: PuzzleState> InnerOrbitPruningTable<P> for ExactPruningTable<UncompressedStorageBackend> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size: u64,
    ) -> (ExactPruningTable<UncompressedStorageBackend>, u64) {
        todo!();
    }
}

impl<P: PuzzleState> InnerOrbitPruningTable<P> for ExactPruningTable<TANSStorageBackend> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size: u64,
    ) -> (ExactPruningTable<TANSStorageBackend>, u64) {
        todo!();
    }
}

impl<P: PuzzleState> InnerOrbitPruningTable<P> for ExactPruningTable<ZeroStorageBackend> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size: u64,
    ) -> (ExactPruningTable<ZeroStorageBackend>, u64) {
        (
            ExactPruningTable {
                storage_backend: ZeroStorageBackend,
                orbit_index,
            },
            0,
        )
    }
}

impl<P: PuzzleState> InnerOrbitPruningTable<P>
    for CycleTypePruningTable<UncompressedStorageBackend>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size: u64,
    ) -> (CycleTypePruningTable<UncompressedStorageBackend>, u64) {
        todo!();
    }
}

impl<P: PuzzleState> InnerOrbitPruningTable<P> for CycleTypePruningTable<TANSStorageBackend> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size: u64,
    ) -> (CycleTypePruningTable<TANSStorageBackend>, u64) {
        todo!();
    }
}

impl<'a, P: PuzzleState + 'a> PruningTables<'a, P> for ZeroTable<P> {
    type GenerateMeta = ();

    fn generate(_generate_meta: ()) -> Self {
        ZeroTable(std::marker::PhantomData)
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

#[cfg(test)]
mod tests {}
