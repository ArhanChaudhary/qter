//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use crate::phase2::puzzle::{MultiBvInterface, orbit_puzzle::SliceOrbitPuzzle};

use super::{
    FACT_UNTIL_20,
    puzzle::{OrbitDef, OrientedPartition, PuzzleDef, PuzzleState, orbit_puzzle::OrbitPuzzleState},
};
use itertools::Itertools;
use std::{iter::repeat_n, num::NonZeroU8};
use thiserror::Error;

pub trait PruningTables<P: PuzzleState> {
    type GenerateMeta<'a>
    where
        P: 'a;

    fn generate(generate_meta: Self::GenerateMeta<'_>) -> Self;
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

/// A trait for a pruning table storage backend
pub trait StorageBackend<const EXACT: bool> {
    type InitializationMeta: From<u64>;

    /// Initialize the storage backend from the given meta information
    fn initialize_from_meta(intialization_meta: Self::InitializationMeta) -> Self;

    /// Get a **permissible** heuristic from a hash. This is expected to be
    /// implemented as a light wrapper around `heuristic_hash`.
    fn permissible_heuristic_hash(&self, hash: u64) -> u8;

    /// Get a raw heuristic from a hash. The separation is necessary or else
    /// there would otherwise be no way to check if an entry is vacant before
    /// setting it to a value during pruning table generation. A raw getter is
    /// also faster because it avoids the `depth_traversed` overhead with
    /// `permissible_heuristic_hash`.
    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic;

    /// Set the heuristic for a hash.
    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic);

    /// Commit the depth traversed for the pruning table, used to represent the
    /// heuristic for vacant entries.
    fn commit_depth_traversed(&mut self, depth_traversed: u8);
}

/// A pruning table acting on a single orbit.
trait OrbitPruningTable<P: PuzzleState> {
    /// Generate a filled pruning table for a given orbit.
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (Self, u64)
    where
        Self: Sized;

    /// Get a **permissible** heuristic for a puzzle state. It is a soundness
    /// error if this is not the case. Implementors are expected to have a
    /// mechanism to identify the table's target orbit.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

pub struct OrbitPruningTables<P: PuzzleState> {
    orbit_pruning_tables: Box<[Box<dyn OrbitPruningTable<P>>]>,
}

pub struct OrbitPruningTablesGenerateMeta<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    sorted_cycle_type: &'a [OrientedPartition],
    max_size_bytes: u64,
    table_types: Option<Vec<(OrbitPruningTableTy, StorageBackendTy)>>,
}

pub struct UncompressedStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    depth_traversed: u8,
}

struct TANSStorageEncodingTable {
    // silly things here
}

pub struct TANSStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    counts_by_depth: Box<[u64]>,
    encoding_tables: Box<[TANSStorageEncodingTable]>,
}

pub struct ApproximateOrbitPruningTable<S: StorageBackend<false>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

pub struct ExactOrbitPruningTable<S: StorageBackend<true>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

pub struct CycleTypeOrbitPruningTable<S: StorageBackend<true>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

/// This type isn't actually entirely useless; I will use it for tables that
/// have no remaining allocable space (by the `max_size_bytes` option).
pub struct ZeroOrbitTable;

#[derive(Error, Debug)]
pub enum TableTypeError {
    #[error("Invalid sorted cycle type length: expected {expected}, actual {actual}")]
    InvalidSortedCycleTypeLength { expected: usize, actual: usize },
    #[error("Invalid table types length: expected {expected}, actual {actual}")]
    InvalidTableTypesLength { expected: usize, actual: usize },
    #[error("Invalid orbit puzzle types length: expected {expected}, actual {actual}")]
    InvalidOrbitPuzzleTypesLength { expected: usize, actual: usize },
    #[error("Puzzle state cannot be an orbit puzzle")]
    PuzzleStateCannotBeOrbitPuzzle,
}

#[derive(Default, PartialEq, Debug, Clone, Copy)]
pub enum OrbitPruningTableTy {
    Approximate,
    Exact,
    CycleType,
    Zero,
    #[default]
    Dynamic,
}

#[derive(Default, PartialEq, Debug, Clone, Copy)]
pub enum StorageBackendTy {
    Uncompressed,
    Tans,
    Zero,
    #[default]
    Dynamic,
}

pub struct ZeroTable<P: PuzzleState>(std::marker::PhantomData<P>);

use private::OrbitPruneHeuristic;
mod private {
    #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
    pub struct OrbitPruneHeuristic(u8);

    impl OrbitPruneHeuristic {
        const VACANT: u8 = u8::MAX;

        pub fn vacant() -> OrbitPruneHeuristic {
            OrbitPruneHeuristic(Self::VACANT)
        }

        pub fn occupied(depth_traversed: u8) -> Option<OrbitPruneHeuristic> {
            if depth_traversed == Self::VACANT {
                None
            } else {
                Some(OrbitPruneHeuristic(depth_traversed))
            }
        }

        pub fn is_vacant(self) -> bool {
            self.0 == Self::VACANT
        }

        pub fn get_occupied(self) -> Option<u8> {
            if self.is_vacant() { None } else { Some(self.0) }
        }
    }
}

pub struct MaxSizeBytes(pub u64);
pub struct MaxEntries(pub usize);
pub struct NullMeta;

impl From<u64> for MaxSizeBytes {
    fn from(value: u64) -> Self {
        MaxSizeBytes(value)
    }
}

impl From<u64> for MaxEntries {
    fn from(value: u64) -> Self {
        MaxEntries(value.try_into().unwrap())
    }
}

impl From<u64> for NullMeta {
    fn from(_: u64) -> Self {
        NullMeta
    }
}

impl<'a, P: PuzzleState> OrbitPruningTablesGenerateMeta<'a, P> {
    /// Create a new `OrbitPruningTablesGenerateMeta` with the given parameters.
    ///
    /// # Errors
    ///
    /// Returns an error if the length of `sorted_cycle_type` does not match
    pub fn new(
        puzzle_def: &'a PuzzleDef<P>,
        sorted_cycle_type: &'a [OrientedPartition],
        max_size_bytes: u64,
    ) -> Result<Self, TableTypeError> {
        if sorted_cycle_type.len() != puzzle_def.sorted_orbit_defs.len() {
            return Err(TableTypeError::InvalidSortedCycleTypeLength {
                expected: puzzle_def.sorted_orbit_defs.len(),
                actual: sorted_cycle_type.len(),
            });
        }
        Ok(OrbitPruningTablesGenerateMeta {
            puzzle_def,
            sorted_cycle_type,
            max_size_bytes,
            table_types: None,
        })
    }

    /// Create a new `OrbitPruningTablesGenerateMeta` with the given parameters
    ///
    /// # Errors
    ///
    /// Returns an error if the length of `sorted_cycle_type` does not match
    pub fn new_with_table_types(
        puzzle_def: &'a PuzzleDef<P>,
        sorted_cycle_type: &'a [OrientedPartition],
        table_types: Vec<(OrbitPruningTableTy, StorageBackendTy)>,
        max_size_bytes: u64,
    ) -> Result<Self, TableTypeError> {
        let mut ret = Self::new(puzzle_def, sorted_cycle_type, max_size_bytes)?;
        if table_types.len() != puzzle_def.sorted_orbit_defs.len() {
            return Err(TableTypeError::InvalidTableTypesLength {
                expected: puzzle_def.sorted_orbit_defs.len(),
                actual: table_types.len(),
            });
        }
        ret.table_types = Some(table_types);
        Ok(ret)
    }
}

impl<P: PuzzleState> PruningTables<P> for OrbitPruningTables<P> {
    type GenerateMeta<'a>
        = OrbitPruningTablesGenerateMeta<'a, P>
    where
        P: 'a;

    fn generate(generate_meta: OrbitPruningTablesGenerateMeta<P>) -> OrbitPruningTables<P> {
        let mut orbit_pruning_tables =
            Vec::with_capacity(generate_meta.puzzle_def.sorted_orbit_defs.len());
        let mut remaining_size_bytes = generate_meta.max_size_bytes;
        // Already sorted by (piece count, orientation) which is (usually) from
        // smallest to largest which makes this work. This essentially populates
        // the smallest pruning tables while dynamically updating how much space
        // is reserved for the remaining orbit tables.
        let mut orbit_identifier = 0;
        for orbit_index in 0..generate_meta.puzzle_def.sorted_orbit_defs.len() {
            let table_type = generate_meta
                .table_types
                .as_ref()
                .map(|table_types| table_types[orbit_index]);

            let sorted_orbit_cycle_type = &generate_meta.sorted_cycle_type[orbit_index];

            let orbit_def = generate_meta.puzzle_def.sorted_orbit_defs[orbit_index];

            let unprocessed_orbits_count =
                generate_meta.puzzle_def.sorted_orbit_defs.len() - orbit_index;
            let max_size_bytes = remaining_size_bytes / unprocessed_orbits_count as u64;

            let (orbit_pruning_table, used_size_bytes) = choose_pruning_table(
                generate_meta.puzzle_def,
                table_type,
                sorted_orbit_cycle_type,
                orbit_def,
                orbit_identifier,
                max_size_bytes,
            );

            remaining_size_bytes -= used_size_bytes;
            orbit_identifier = P::next_orbit_identifer(orbit_identifier, orbit_def);
            orbit_pruning_tables.push(orbit_pruning_table);
        }

        OrbitPruningTables {
            orbit_pruning_tables: orbit_pruning_tables.into_boxed_slice(),
        }
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.orbit_pruning_tables
            .iter()
            .fold(0, |best_bound, orbit_pruning_table| {
                best_bound.max(orbit_pruning_table.permissible_heuristic(puzzle_state))
            })
    }
}

/// Choose the appropriate pruning table based on numerous fields. Returns a
/// filled-in pruning table trait object along with its size in bytes.
fn choose_pruning_table<P: PuzzleState>(
    puzzle_def: &PuzzleDef<P>,
    table_type: Option<(OrbitPruningTableTy, StorageBackendTy)>,
    sorted_orbit_cycle_type: &OrientedPartition,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
    max_size_bytes: u64,
) -> (Box<dyn OrbitPruningTable<P>>, u64) {
    macro_rules! table {
        ($a:ident, $b:ident, $c:ident) => {{
            let (table, used_size_bytes) = $a::<$b<{ $c }>>::generate(
                puzzle_def,
                sorted_orbit_cycle_type,
                orbit_def,
                orbit_identifier,
                max_size_bytes,
            );
            return (Box::new(table), used_size_bytes);
        }};

        ($a:ident) => {{
            let (table, used_size_bytes) = $a::generate(
                puzzle_def,
                sorted_orbit_cycle_type,
                orbit_def,
                orbit_identifier,
                max_size_bytes,
            );
            return (Box::new(table), used_size_bytes);
        }};
    }

    if let Some((table_type, storage_backend_type)) = table_type {
        match (table_type, storage_backend_type) {
            (OrbitPruningTableTy::Approximate, StorageBackendTy::Uncompressed) => {
                table!(
                    ApproximateOrbitPruningTable,
                    UncompressedStorageBackend,
                    false
                )
            }
            (OrbitPruningTableTy::Approximate, StorageBackendTy::Tans) => {
                table!(ApproximateOrbitPruningTable, TANSStorageBackend, false)
            }
            (OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed) => {
                table!(ExactOrbitPruningTable, UncompressedStorageBackend, true)
            }
            (OrbitPruningTableTy::Exact, StorageBackendTy::Tans) => {
                table!(ExactOrbitPruningTable, TANSStorageBackend, true)
            }
            (OrbitPruningTableTy::CycleType, StorageBackendTy::Uncompressed) => {
                table!(CycleTypeOrbitPruningTable, UncompressedStorageBackend, true)
            }
            (OrbitPruningTableTy::CycleType, StorageBackendTy::Tans) => {
                table!(CycleTypeOrbitPruningTable, TANSStorageBackend, true)
            }
            (OrbitPruningTableTy::Zero, _) | (_, StorageBackendTy::Zero) => {
                table!(ZeroOrbitTable)
            }
            (OrbitPruningTableTy::Dynamic, _) | (_, StorageBackendTy::Dynamic) => (),
        }
    }

    todo!();
}

impl<const EXACT: bool> StorageBackend<EXACT> for UncompressedStorageBackend<EXACT> {
    type InitializationMeta = MaxEntries;

    fn initialize_from_meta(max_entries: MaxEntries) -> UncompressedStorageBackend<EXACT> {
        let max_entries = max_entries.0;
        let data = vec![OrbitPruneHeuristic::vacant(); max_entries].into_boxed_slice();
        UncompressedStorageBackend {
            data,
            depth_traversed: 0,
        }
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        self.heuristic_hash(hash)
            .get_occupied()
            .unwrap_or(self.depth_traversed)
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        if EXACT {
            #[allow(clippy::cast_possible_truncation)]
            // an exact hash implies (0..self.data.len()).contains(hash) . This
            // also implies that hash is no larger than `self.data.len()` which
            // is a usize. Therefore we can safely cast it to a usize given this
            // condition upheld by the caller.
            self.data[hash as usize]
        } else {
            let hash = hash % self.data.len() as u64;
            #[allow(clippy::cast_possible_truncation)]
            // After the modulus `hash` is guaranteed to be less than
            // `self.data.len()` which is a usize. Therefore we can safely cast
            // it to a usize.
            self.data[hash as usize]
        }
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            #[allow(clippy::cast_possible_truncation)]
            // see above for why this is safe
            let hash = hash as usize;
            self.data[hash] = orbit_prune_heuristic;
        } else {
            let hash = hash % self.data.len() as u64;
            #[allow(clippy::cast_possible_truncation)]
            // see above for why this is safe
            let hash = hash as usize;
            self.data[hash] = self.data[hash].min(orbit_prune_heuristic);
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        self.depth_traversed = depth_traversed;
    }
}

impl<const EXACT: bool> StorageBackend<EXACT> for TANSStorageBackend<EXACT> {
    type InitializationMeta = u64;

    fn initialize_from_meta(initialization_meta: u64) -> TANSStorageBackend<EXACT> {
        if EXACT {
            let entry_count = initialization_meta;
            todo!();
        } else {
            let max_size_bytes = initialization_meta;
            todo!();
        }
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        todo!();
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        todo!();
    }
}

impl<P: PuzzleState, S: StorageBackend<false>> OrbitPruningTable<P>
    for ApproximateOrbitPruningTable<S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (ApproximateOrbitPruningTable<S>, u64) {
        todo!();
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.storage_backend
            .permissible_heuristic_hash(fxhash::hash64(
                &puzzle_state.approximate_hash_orbit(self.orbit_identifier, self.orbit_def),
            ))
    }
}

fn generate_exact_orbit_pruning_table<
    P: PuzzleState,
    O: OrbitPuzzleState,
    S: StorageBackend<true>,
>(
    puzzle_def: &PuzzleDef<P>,
    sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
    orbit_def: OrbitDef,
    orbit_identifier: usize,
    max_size_bytes: u64,
) -> Option<(ExactOrbitPruningTable<S>, u64)> {
    let piece_count = orbit_def.piece_count.get();

    let entry_count = FACT_UNTIL_20[piece_count as usize]
        * u64::pow(
            u64::from(orbit_def.orientation_count.get()),
            u32::from(piece_count) - 1,
        );

    let orbit_moves = puzzle_def
        .moves
        .iter()
        // TODO: make this filter map
        .map(|move_| {
            // TODO: better way to do this?
            let (perm, ori) = move_.puzzle_state.orbit_bytes(orbit_identifier, orbit_def);
            O::from_orbit_transformation_unchecked(perm, ori, orbit_def)
        })
        .collect_vec();

    let mut ret = ExactOrbitPruningTable {
        storage_backend: S::initialize_from_meta(entry_count.into()),
        orbit_def,
        orbit_identifier,
    };

    let perm = (0..piece_count).collect_vec();
    let ori = vec![0; piece_count as usize - 1];
    let mut result = O::from_orbit_transformation_unchecked(&perm, &ori, orbit_def);

    let mut multi_bv = O::new_multi_bv(sorted_orbit_cycle_type);
    let mut depth = 0;
    let mut vacant_entry_count = entry_count;

    let mut exact_orbit_hash = 0;
    while let Some(depth_heuristic) = OrbitPruneHeuristic::occupied(depth) {
        for perm in (0..piece_count).permutations(piece_count as usize) {
            for ori in repeat_n(0..orbit_def.orientation_count.get(), piece_count as usize)
                .multi_cartesian_product()
                // TODO more efficient way than filtering and this overflows too
                .filter(|ori| {
                    ori.iter()
                        .sum::<u8>()
                        .rem_euclid(orbit_def.orientation_count.get())
                        == 0
                })
            {
                if depth != 0
                    && ret
                        .storage_backend
                        .heuristic_hash(exact_orbit_hash)
                        .get_occupied()
                        != Some(depth - 1)
                {
                    exact_orbit_hash += 1;
                    continue;
                }

                let curr_state = O::from_orbit_transformation_unchecked(&perm, &ori, orbit_def);
                if depth == 0 {
                    if curr_state.induces_sorted_orbit_cycle_type(
                        sorted_orbit_cycle_type,
                        orbit_def,
                        multi_bv.reusable_ref(),
                    ) {
                        ret.storage_backend
                            .set_heuristic_hash(exact_orbit_hash, depth_heuristic);
                        vacant_entry_count -= 1;
                    }
                    exact_orbit_hash += 1;
                    continue;
                }

                for move_ in &orbit_moves {
                    result.replace_compose(&curr_state, move_, orbit_def);
                    let new_hash = result.exact_hash(orbit_def);
                    if ret.storage_backend.heuristic_hash(new_hash).is_vacant() {
                        ret.storage_backend
                            .set_heuristic_hash(new_hash, depth_heuristic);
                        vacant_entry_count -= 1;
                    }
                }
                exact_orbit_hash += 1;
            }
        }
        if vacant_entry_count == 0 {
            assert_eq!(exact_orbit_hash, entry_count);
            break;
        }
        depth += 1;
    }
    Some((ret, entry_count))
}

impl<P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<P> for ExactOrbitPruningTable<S> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (ExactOrbitPruningTable<S>, u64) {
        macro_rules! table {
            ($a:ident) => {{
                let (table, used_size_bytes) = generate_exact_orbit_pruning_table::<P, $a, S>(
                    puzzle_def,
                    sorted_orbit_cycle_type,
                    orbit_def,
                    orbit_identifier,
                    max_size_bytes,
                    // TODO
                )
                .unwrap();
                return (table, used_size_bytes);
            }};
        }

        // TODO: pick an orbit puzzle type
        table!(SliceOrbitPuzzle)
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.storage_backend.permissible_heuristic_hash(
            puzzle_state.exact_hash_orbit(self.orbit_identifier, self.orbit_def),
        )
    }
}

impl<P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<P>
    for CycleTypeOrbitPruningTable<S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (CycleTypeOrbitPruningTable<S>, u64) {
        todo!();
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        let hash = todo!();
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<P: PuzzleState> OrbitPruningTable<P> for ZeroOrbitTable {
    fn generate(
        _puzzle_def: &PuzzleDef<P>,
        _sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        _orbit_def: OrbitDef,
        _orbit_identifier: usize,
        _max_size_bytes: u64,
    ) -> (ZeroOrbitTable, u64) {
        (ZeroOrbitTable, 0)
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        0
    }
}

impl<P: PuzzleState> PruningTables<P> for ZeroTable<P> {
    type GenerateMeta<'a>
        = NullMeta
    where
        P: 'a;

    fn generate(_: NullMeta) -> ZeroTable<P> {
        ZeroTable(std::marker::PhantomData)
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::phase2::puzzle::{
        apply_moves, cube3::Cube3, random_3x3_state, slice_puzzle::HeapPuzzle,
    };
    use puzzle_geometry::ksolve::KPUZZLE_3X3;

    #[test]
    fn test_orbit_prune_heuristic_invariants() {
        let vacant = OrbitPruneHeuristic::vacant();
        assert!(vacant.is_vacant());
        assert_eq!(vacant.get_occupied(), None);

        let occupied = OrbitPruneHeuristic::occupied(5).unwrap();
        assert!(!occupied.is_vacant());
        assert_eq!(occupied.get_occupied(), Some(5));

        let occupied = OrbitPruneHeuristic::occupied(255);
        assert!(occupied.is_none());
    }

    #[test]
    fn test_exact_uncompressed_storage_backend() {
        let mut storage = UncompressedStorageBackend::<true>::initialize_from_meta(MaxEntries(100));

        storage.set_heuristic_hash(5, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(5), 3);

        assert_eq!(storage.permissible_heuristic_hash(6), 0);
        storage.commit_depth_traversed(4);
        assert_eq!(storage.permissible_heuristic_hash(6), 4);
        assert_eq!(storage.permissible_heuristic_hash(5), 3);
    }

    #[test]
    fn test_approximate_uncompressed_storage_backend() {
        let mut storage =
            UncompressedStorageBackend::<false>::initialize_from_meta(MaxEntries(100));

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 3);

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(2).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 2);
    }

    #[test]
    fn test_zero_orbit_tables() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let solved = cube3_def.new_solved_state();
        let u_move = cube3_def.find_move("U").unwrap();
        let identity_cycle_type = [vec![], vec![]];

        let (zero_orbit_table, _) =
            ZeroOrbitTable::generate(&cube3_def, &[], cube3_def.sorted_orbit_defs[0], 0, 0);
        assert_eq!(zero_orbit_table.permissible_heuristic(&solved), 0);
        assert_eq!(
            zero_orbit_table.permissible_heuristic(&u_move.puzzle_state),
            0
        );

        let generate_meta = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &identity_cycle_type,
            vec![
                (OrbitPruningTableTy::Exact, StorageBackendTy::Zero),
                (OrbitPruningTableTy::Exact, StorageBackendTy::Zero),
            ],
            0,
        )
        .unwrap();
        let orbit_tables = OrbitPruningTables::generate(generate_meta);

        assert_eq!(orbit_tables.permissible_heuristic(&solved), 0);
        assert_eq!(orbit_tables.permissible_heuristic(&u_move.puzzle_state), 0);
    }

    #[test]
    fn test_zero_table() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let zero_table = ZeroTable::generate(NullMeta);

        let random_state = random_3x3_state(&cube3_def, &cube3_def.new_solved_state());
        assert_eq!(zero_table.permissible_heuristic(&random_state), 0);
    }

    #[test]
    fn test_table_type_defaults() {
        assert_eq!(OrbitPruningTableTy::Dynamic, OrbitPruningTableTy::default());
        assert_eq!(StorageBackendTy::Dynamic, StorageBackendTy::default());
    }

    #[test]
    fn test_new_orbit_generation_meta() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let identity_cycle_type = [vec![], vec![]];
        let generate_meta =
            OrbitPruningTablesGenerateMeta::new(&cube3_def, &identity_cycle_type, 1000).unwrap();
        assert_eq!(generate_meta.max_size_bytes, 1000);
        assert!(generate_meta.table_types.is_none());

        assert!(
            OrbitPruningTablesGenerateMeta::new_with_table_types(
                &cube3_def,
                &identity_cycle_type,
                vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed)],
                1000,
            )
            .is_err()
        );

        OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &identity_cycle_type,
            vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed); 2],
            1000,
        )
        .unwrap();
    }

    // #[test]
    // fn test_exact_orbit_hasher_only_hashes_orbit() {
    //     let cube3_def: PuzzleDef<HeapPuzzle> = (&*KPUZZLE_3X3).try_into().unwrap();
    //     let solved = cube3_def.new_solved_state();
    //     let mut result_1 = solved.clone();
    //     let mut result_2 = solved.clone();
    //     let u_move = cube3_def.find_move("U").unwrap();

    //     let exact_corners_pruning_table =
    //         ExactOrbitPruningTable::<UncompressedStorageBackend<true>> {
    //             storage_backend: UncompressedStorageBackend::initialize_from_meta(MaxEntries(100)),
    //             orbit_def: cube3_def.sorted_orbit_defs[0],
    //             orbit_identifier: 0,
    //         };

    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&solved), 0);
    //     result_1.replace_compose(&solved, &u_move.puzzle_state, &cube3_def.sorted_orbit_defs);
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         24476904
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         57868020
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         67775130
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_2), 0);

    //     // shortest 11 cycle alg
    //     result_1 = apply_moves(&cube3_def, &solved, "U R U F L R' U' R' F' D'", 1);

    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         24476904
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         57868020
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         67775130
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);

    //     assert_ne!(solved, result_1);
    // }
}
