//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use crate::phase2::{
    orbit_puzzle::{
        OrbitPuzzleConstructors, OrbitPuzzleState, slice_orbit_puzzle::SliceOrbitPuzzle,
    },
    puzzle::MultiBvInterface,
};

use super::{
    FACT_UNTIL_19,
    puzzle::{OrbitDef, OrientedPartition, PuzzleDef, PuzzleState},
};
use itertools::Itertools;
use std::{
    iter::repeat_n,
    num::{NonZeroU8, NonZeroUsize},
};
use thiserror::Error;

pub trait PruningTables<P: PuzzleState> {
    type GenerateMetas<'a>
    where
        P: 'a;
    type GenerateError;

    /// Generate pruning tables for a puzzle
    ///
    /// # Errors
    ///
    /// Returns an error if the generation fails
    fn try_generate(generate_metas: Self::GenerateMetas<'_>) -> Result<Self, Self::GenerateError>
    where
        Self: Sized;

    /// Get a permissible heuristic for a puzzle state. It is a soundness error
    /// if this is not the case.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

/// A trait for a pruning table storage backend
pub trait StorageBackend<const EXACT: bool> {
    type InitializationMeta: UsedSizeBytes;

    /// Initialize the storage backend from an entry count.
    fn initialize_from_meta(initialization_meta: Self::InitializationMeta) -> Self;

    // TODO: almost certainly these signatures need changing. For example adding
    // orbit FSMs as arguments. I've left the API fairly flexible; Henry you can
    // change this however.
    fn initialization_meta_from_entry_count(entry_count: usize) -> Self::InitializationMeta;

    fn initialization_meta_from_max_size_bytes(max_size_bytes: usize) -> Self::InitializationMeta;

    /// Get a **permissible** heuristic from a hash. This is expected to be
    /// implemented as a light wrapper around `heuristic_hash`.
    fn permissible_heuristic_hash(&self, hash: u64) -> u8;

    /// Get a raw heuristic from a hash. The separation is necessary or else
    /// there would otherwise be no way to check if an entry is vacant before
    /// setting it to a value during pruning table generation. A raw getter is
    /// also faster because it avoids the `depth_traversed` overhead with
    /// `permissible_heuristic_hash`.
    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic;

    /// Set the heuristic for a hash.
    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic);

    /// Commit the depth traversed for the pruning table, used to represent the
    /// heuristic for vacant entries.
    fn commit_depth_traversed(&mut self, depth_traversed: u8);
}

/// A pruning table acting on a single orbit.
trait OrbitPruningTable<P: PuzzleState> {
    /// Generate a pruning table for a target orbit.
    fn try_generate(
        generate_meta: OrbitPruningTableGenerationMeta<P>,
    ) -> Result<
        (Self, usize),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<P>,
        ),
    >
    where
        Self: Sized;

    /// Get a permissible heuristic for a puzzle state for a target orbit. It
    /// is a soundness error if this is not the case. Implementors are expected
    /// to have a mechanism to identify the table's target orbit.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

// Not completely sure what this trait should look like; Henry change this if
// you need to for tANS.
pub trait UsedSizeBytes {
    fn used_size_bytes(&self) -> usize;
}

pub struct OrbitPruningTables<P: PuzzleState> {
    orbit_pruning_tables: Box<[Box<dyn OrbitPruningTable<P>>]>,
}

#[derive(Debug)]
struct OrbitPruningTableGenerationMeta<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    sorted_orbit_cycle_type: &'a [(NonZeroU8, bool)],
    orbit_def: OrbitDef,
    orbit_identifier: usize,
    max_size_bytes: usize,
}

pub struct OrbitPruningTablesGenerateMeta<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    sorted_cycle_type: &'a [OrientedPartition],
    max_size_bytes: usize,
    maybe_table_types: Option<Vec<(OrbitPruningTableTy, StorageBackendTy)>>,
}

pub struct UncompressedStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    depth_traversed: u8,
}

#[derive(Clone)]
struct TANSStorageEncodingTable {
    // silly things here
}

pub struct TANSStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    counts_by_depth: Box<[u64]>,
    encoding_tables: Box<[TANSStorageEncodingTable]>,
}

pub struct MaxSizeBytes(pub usize);

pub struct TANSDistributionEstimation {
    max_size_bytes: usize,
    // distribution stuff
}

pub struct ApproximateOrbitPruningTable<S: StorageBackend<false>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

pub struct ExactOrbitPruningTable<S: StorageBackend<true>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

pub struct CycleTypeOrbitPruningTable {
    data: Box<[OrbitPruneHeuristic]>,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

/// This type isn't actually entirely useless; I will use it for tables that
/// have no remaining allocable space (by the `max_size_bytes` option).
pub struct ZeroOrbitTable;

#[derive(Error, Debug)]
pub enum OrbitPruningTableGenerationError {
    #[error("Orbit pruning table is not large enough to hold all entries")]
    NotBigEnough,
    #[error("Orbit pruning table stores too many entries")]
    TooLargeLoadFactor,
}

#[derive(Error, Debug)]
pub enum TableTypeInstantiationError {
    #[error("Invalid sorted cycle type length: expected {expected}, actual {actual}")]
    InvalidSortedCycleTypeLength { expected: usize, actual: usize },
    #[error("Invalid table types length: expected {expected}, actual {actual}")]
    InvalidTableTypesLength { expected: usize, actual: usize },
    #[error("Invalid orbit puzzle types length: expected {expected}, actual {actual}")]
    InvalidOrbitPuzzleTypesLength { expected: usize, actual: usize },
    #[error("Puzzle state cannot be an orbit puzzle")]
    PuzzleStateCannotBeOrbitPuzzle,
    #[error("Table type ({0:?}, {1:?}) not supported for this orbit puzzle type")]
    NotSupported(OrbitPruningTableTy, StorageBackendTy),
}

#[derive(PartialEq, Debug, Clone, Copy)]
pub enum OrbitPruningTableTy {
    Approximate,
    Exact,
    CycleType,
    Zero,
    Dynamic,
}

#[derive(PartialEq, Debug, Clone, Copy)]
pub enum StorageBackendTy {
    Uncompressed,
    Tans,
    Zero,
    Dynamic,
}

pub struct ZeroTable<P: PuzzleState>(std::marker::PhantomData<P>);

use private::OrbitPruneHeuristic;
mod private {
    #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
    pub struct OrbitPruneHeuristic(u8);

    impl OrbitPruneHeuristic {
        const VACANT: u8 = u8::MAX;

        pub fn vacant() -> OrbitPruneHeuristic {
            OrbitPruneHeuristic(Self::VACANT)
        }

        pub fn occupied(depth_traversed: u8) -> Option<OrbitPruneHeuristic> {
            if depth_traversed == Self::VACANT {
                None
            } else {
                Some(OrbitPruneHeuristic(depth_traversed))
            }
        }

        pub fn is_vacant(self) -> bool {
            self.0 == Self::VACANT
        }

        pub fn get_occupied(self) -> Option<u8> {
            if self.is_vacant() { None } else { Some(self.0) }
        }
    }
}

impl UsedSizeBytes for MaxSizeBytes {
    fn used_size_bytes(&self) -> usize {
        self.0
    }
}

impl UsedSizeBytes for TANSDistributionEstimation {
    fn used_size_bytes(&self) -> usize {
        self.max_size_bytes
    }
}

impl<'a, P: PuzzleState> OrbitPruningTablesGenerateMeta<'a, P> {
    /// Create a new `OrbitPruningTablesGenerateMeta` with the given parameters.
    ///
    /// # Errors
    ///
    /// Returns an error if the length of `sorted_cycle_type` does not match
    pub fn new(
        puzzle_def: &'a PuzzleDef<P>,
        sorted_cycle_type: &'a [OrientedPartition],
        max_size_bytes: usize,
    ) -> Result<Self, TableTypeInstantiationError> {
        if sorted_cycle_type.len() != puzzle_def.sorted_orbit_defs.len() {
            return Err(TableTypeInstantiationError::InvalidSortedCycleTypeLength {
                expected: puzzle_def.sorted_orbit_defs.len(),
                actual: sorted_cycle_type.len(),
            });
        }
        Ok(OrbitPruningTablesGenerateMeta {
            puzzle_def,
            sorted_cycle_type,
            max_size_bytes,
            maybe_table_types: None,
        })
    }

    /// Create a new `OrbitPruningTablesGenerateMeta` with the given parameters
    ///
    /// # Errors
    ///
    /// Returns an error if the length of `sorted_cycle_type` does not match
    pub fn new_with_table_types(
        puzzle_def: &'a PuzzleDef<P>,
        sorted_cycle_type: &'a [OrientedPartition],
        table_types: Vec<(OrbitPruningTableTy, StorageBackendTy)>,
        max_size_bytes: usize,
    ) -> Result<Self, TableTypeInstantiationError> {
        let mut generate_metas = Self::new(puzzle_def, sorted_cycle_type, max_size_bytes)?;
        if table_types.len() != puzzle_def.sorted_orbit_defs.len() {
            return Err(TableTypeInstantiationError::InvalidTableTypesLength {
                expected: puzzle_def.sorted_orbit_defs.len(),
                actual: table_types.len(),
            });
        }
        if table_types.iter().any(|table_type| {
            matches!(
                table_type,
                (OrbitPruningTableTy::CycleType, StorageBackendTy::Tans)
            )
        }) {
            return Err(TableTypeInstantiationError::NotSupported(
                OrbitPruningTableTy::CycleType,
                StorageBackendTy::Tans,
            ));
        }
        generate_metas.maybe_table_types = Some(table_types);
        Ok(generate_metas)
    }
}

impl<P: PuzzleState> PruningTables<P> for OrbitPruningTables<P> {
    type GenerateMetas<'a>
        = OrbitPruningTablesGenerateMeta<'a, P>
    where
        P: 'a;
    type GenerateError = OrbitPruningTableGenerationError;

    fn try_generate(
        generate_metas: OrbitPruningTablesGenerateMeta<P>,
    ) -> Result<OrbitPruningTables<P>, OrbitPruningTableGenerationError> {
        let mut orbit_pruning_tables =
            Vec::with_capacity(generate_metas.puzzle_def.sorted_orbit_defs.len());
        let mut remaining_size_bytes = generate_metas.max_size_bytes;
        // Already sorted by (piece count, orientation) which is (usually) from
        // smallest to largest which makes this work. This essentially populates
        // the smallest pruning tables while dynamically updating how much space
        // is reserved for the remaining orbit tables.
        let mut orbit_identifier = 0;
        for (orbit_index, &orbit_def) in generate_metas
            .puzzle_def
            .sorted_orbit_defs
            .iter()
            .enumerate()
        {
            let maybe_table_type = generate_metas
                .maybe_table_types
                .as_ref()
                .map(|table_types| table_types[orbit_index]);

            let sorted_orbit_cycle_type = &generate_metas.sorted_cycle_type[orbit_index];

            let unprocessed_orbits_count = NonZeroUsize::new(
                generate_metas.puzzle_def.sorted_orbit_defs.len()
                    - orbit_index
                    - generate_metas
                        .maybe_table_types
                        .as_ref()
                        .map_or(0, |table_types| {
                            table_types
                                .iter()
                                .skip(orbit_index)
                                .copied()
                                .filter(|&table_type| {
                                    matches!(
                                        table_type,
                                        (OrbitPruningTableTy::Zero, _)
                                            | (_, StorageBackendTy::Zero)
                                    )
                                })
                                .count()
                        }),
            )
            .unwrap_or_else(|| {
                assert!(matches!(
                    maybe_table_type,
                    Some((OrbitPruningTableTy::Zero, _) | (_, StorageBackendTy::Zero))
                ));
                NonZeroUsize::new(1).unwrap()
            });
            assert!(
                unprocessed_orbits_count.get() <= generate_metas.puzzle_def.sorted_orbit_defs.len()
            );

            let max_size_bytes = remaining_size_bytes / unprocessed_orbits_count;

            let generate_meta = OrbitPruningTableGenerationMeta {
                puzzle_def: generate_metas.puzzle_def,
                sorted_orbit_cycle_type,
                orbit_def,
                orbit_identifier,
                max_size_bytes,
            };

            let (orbit_pruning_table, used_size_bytes) = match maybe_table_type {
                Some(table_type)
                    if !matches!(
                        table_type,
                        (OrbitPruningTableTy::Dynamic, _) | (_, StorageBackendTy::Dynamic)
                    ) =>
                {
                    try_generate_orbit_pruning_table_with_table_type(generate_meta, table_type)?
                }
                _ => generate_orbit_pruning_table(generate_meta),
            };

            remaining_size_bytes -= used_size_bytes;
            orbit_identifier = P::next_orbit_identifer(orbit_identifier, orbit_def);
            orbit_pruning_tables.push(orbit_pruning_table);
        }

        Ok(OrbitPruningTables {
            orbit_pruning_tables: orbit_pruning_tables.into_boxed_slice(),
        })
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.orbit_pruning_tables
            .iter()
            .fold(0, |best_bound, orbit_pruning_table| {
                best_bound.max(orbit_pruning_table.permissible_heuristic(puzzle_state))
            })
    }
}

macro_rules! table_fn {
    ($fn_name:ident, $table:ident, $storage:ident, $exact:ident) => {
        fn $fn_name<P: PuzzleState>(
            generate_meta: OrbitPruningTableGenerationMeta<P>,
        ) -> Result<
            (Box<dyn OrbitPruningTable<P>>, usize),
            (
                OrbitPruningTableGenerationError,
                OrbitPruningTableGenerationMeta<P>,
            ),
        > {
            let (table, used_size_bytes) =
                $table::<$storage<{ $exact }>>::try_generate(generate_meta)?;
            Ok((Box::new(table), used_size_bytes))
        }
    };
    ($fn_name:ident, $table:ident) => {
        fn $fn_name<P: PuzzleState>(
            generate_meta: OrbitPruningTableGenerationMeta<P>,
        ) -> Result<
            (Box<dyn OrbitPruningTable<P>>, usize),
            (
                OrbitPruningTableGenerationError,
                OrbitPruningTableGenerationMeta<P>,
            ),
        > {
            let (table, used_size_bytes) = $table::try_generate(generate_meta)?;
            Ok((Box::new(table), used_size_bytes))
        }
    };
}

table_fn! { try_generate_approximate_uncompressed_orbit_table, ApproximateOrbitPruningTable, UncompressedStorageBackend, false }
table_fn! { try_generate_approximate_tans_orbit_table,         ApproximateOrbitPruningTable, TANSStorageBackend,         false }
table_fn! { try_generate_exact_uncompressed_orbit_table,       ExactOrbitPruningTable,       UncompressedStorageBackend, true  }
table_fn! { try_generate_exact_tans_orbit_table,               ExactOrbitPruningTable,       TANSStorageBackend,         true  }
table_fn! { try_generate_cycle_type_uncompressed_orbit_table,  CycleTypeOrbitPruningTable                                      }
table_fn! { try_generate_zero_orbit_table,                     ZeroOrbitTable                                                  }

fn try_generate_orbit_pruning_table_with_table_type<P: PuzzleState>(
    generate_meta: OrbitPruningTableGenerationMeta<P>,
    table_type: (OrbitPruningTableTy, StorageBackendTy),
) -> Result<(Box<dyn OrbitPruningTable<P>>, usize), OrbitPruningTableGenerationError> {
    match table_type {
        (OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed) => {
            try_generate_exact_uncompressed_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        (OrbitPruningTableTy::Exact, StorageBackendTy::Tans) => {
            try_generate_exact_tans_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        (OrbitPruningTableTy::Approximate, StorageBackendTy::Uncompressed) => {
            try_generate_approximate_uncompressed_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        (OrbitPruningTableTy::Approximate, StorageBackendTy::Tans) => {
            try_generate_approximate_tans_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        (OrbitPruningTableTy::CycleType, StorageBackendTy::Uncompressed) => {
            try_generate_cycle_type_uncompressed_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        (OrbitPruningTableTy::CycleType, StorageBackendTy::Tans) => {
            panic!("CycleType orbit tables are not supported for TANS storage backend")
        }
        (OrbitPruningTableTy::Zero, _) | (_, StorageBackendTy::Zero) => {
            Ok(try_generate_zero_orbit_table(generate_meta).unwrap())
        }
        (OrbitPruningTableTy::Dynamic, _) | (_, StorageBackendTy::Dynamic) => {
            panic!("Dynamic orbit tables cannot be specified with a table type")
        }
    }
}

fn generate_orbit_pruning_table<P: PuzzleState>(
    mut generate_meta: OrbitPruningTableGenerationMeta<P>,
) -> (Box<dyn OrbitPruningTable<P>>, usize) {
    for try_table_fn in [
        try_generate_exact_uncompressed_orbit_table,
        try_generate_exact_tans_orbit_table,
        try_generate_approximate_uncompressed_orbit_table,
        try_generate_approximate_tans_orbit_table,
        try_generate_cycle_type_uncompressed_orbit_table,
    ] {
        match try_table_fn(generate_meta) {
            Ok((orbit_pruning_table, used_size_bytes)) => {
                return (orbit_pruning_table, used_size_bytes);
            }
            Err((_, old_generate_meta)) => {
                generate_meta = old_generate_meta;
            }
        }
    }
    try_generate_zero_orbit_table(generate_meta).unwrap()
}

impl<const EXACT: bool> StorageBackend<EXACT> for UncompressedStorageBackend<EXACT> {
    type InitializationMeta = MaxSizeBytes;

    fn initialize_from_meta(initialization_meta: MaxSizeBytes) -> Self {
        let max_size_bytes = initialization_meta.used_size_bytes();
        let data = vec![OrbitPruneHeuristic::vacant(); max_size_bytes].into_boxed_slice();
        UncompressedStorageBackend {
            data,
            depth_traversed: 0,
        }
    }

    fn initialization_meta_from_entry_count(entry_count: usize) -> MaxSizeBytes {
        // Each entry is one byte
        MaxSizeBytes(entry_count)
    }

    fn initialization_meta_from_max_size_bytes(max_size_bytes: usize) -> MaxSizeBytes {
        MaxSizeBytes(max_size_bytes)
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        self.heuristic_hash(hash)
            .get_occupied()
            .unwrap_or(self.depth_traversed)
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        if EXACT {
            #[allow(clippy::cast_possible_truncation)]
            // an exact hash implies (0..self.data.len()).contains(hash) . This
            // also implies that hash is no larger than `self.data.len()` which
            // is a usize. Therefore we can safely cast it to a usize given this
            // condition upheld by the caller.
            self.data[hash as usize]
        } else {
            let hash = hash % self.data.len() as u64;
            #[allow(clippy::cast_possible_truncation)]
            // After the modulus `hash` is guaranteed to be less than
            // `self.data.len()` which is a usize. Therefore we can safely cast
            // it to a usize.
            self.data[hash as usize]
        }
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            #[allow(clippy::cast_possible_truncation)]
            // see above for why this is safe
            let hash = hash as usize;
            self.data[hash] = orbit_prune_heuristic;
        } else {
            let hash = hash % self.data.len() as u64;
            #[allow(clippy::cast_possible_truncation)]
            // see above for why this is safe
            let hash = hash as usize;
            self.data[hash] = self.data[hash].min(orbit_prune_heuristic);
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        self.depth_traversed = depth_traversed;
    }
}

impl<const EXACT: bool> StorageBackend<EXACT> for TANSStorageBackend<EXACT> {
    type InitializationMeta = TANSDistributionEstimation;

    fn initialize_from_meta(initialization_meta: TANSDistributionEstimation) -> Self {
        let used_size_bytes = initialization_meta.used_size_bytes();
        let data = vec![OrbitPruneHeuristic::vacant(); used_size_bytes].into_boxed_slice();
        todo!();
    }

    fn initialization_meta_from_entry_count(entry_count: usize) -> TANSDistributionEstimation {
        // experimentation.ipynb stuff
        todo!();
    }

    fn initialization_meta_from_max_size_bytes(
        max_size_bytes: usize,
    ) -> TANSDistributionEstimation {
        TANSDistributionEstimation { max_size_bytes }
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        todo!();
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        todo!();
    }
}

impl<P: PuzzleState, S: StorageBackend<false>> OrbitPruningTable<P>
    for ApproximateOrbitPruningTable<S>
{
    fn try_generate(
        generate_meta: OrbitPruningTableGenerationMeta<P>,
    ) -> Result<
        (ApproximateOrbitPruningTable<S>, usize),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<P>,
        ),
    > {
        // Decide on a load factor to return an err
        todo!();
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.storage_backend
            .permissible_heuristic_hash(fxhash::hash64(
                &puzzle_state.approximate_hash_orbit(self.orbit_identifier, self.orbit_def),
            ))
    }
}

impl<P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<P> for ExactOrbitPruningTable<S> {
    fn try_generate(
        generate_meta: OrbitPruningTableGenerationMeta<P>,
    ) -> Result<
        (ExactOrbitPruningTable<S>, usize),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<P>,
        ),
    > {
        // TODO: properly pick an orbit puzzle type
        type O = SliceOrbitPuzzle;
        let OrbitPruningTableGenerationMeta {
            puzzle_def,
            sorted_orbit_cycle_type,
            orbit_def,
            orbit_identifier,
            max_size_bytes,
        } = generate_meta;

        // TODO: make this common for all pruning tables
        let piece_count = orbit_def.piece_count.get();

        let entry_count = FACT_UNTIL_19[piece_count as usize]
            * u64::pow(
                u64::from(orbit_def.orientation_count.get()),
                u32::from(piece_count) - 1,
            );

        let initialization_meta =
            S::initialization_meta_from_entry_count(entry_count.try_into().unwrap());
        let used_size_bytes = initialization_meta.used_size_bytes();
        if used_size_bytes > max_size_bytes {
            return Err((
                OrbitPruningTableGenerationError::NotBigEnough,
                generate_meta,
            ));
        }
        let mut table = ExactOrbitPruningTable {
            storage_backend: S::initialize_from_meta(initialization_meta),
            orbit_def,
            orbit_identifier,
        };

        let puzzle_solved = puzzle_def.new_solved_state();
        let (perm, ori) = puzzle_solved.orbit_bytes(orbit_identifier, orbit_def);
        let orbit_solved = O::from_orbit_transformation_unchecked(perm, ori, orbit_def);

        let orbit_move_class_indicies = puzzle_def
            .move_classes
            .iter()
            .copied()
            .enumerate()
            .filter_map(|(i, move_class)| {
                let (perm, ori) = puzzle_def.moves[move_class]
                    .puzzle_state
                    .orbit_bytes(orbit_identifier, orbit_def);
                if O::from_orbit_transformation_unchecked(perm, ori, orbit_def) == orbit_solved {
                    None
                } else {
                    Some(i)
                }
            })
            .collect_vec();

        let orbit_moves = puzzle_def
            .moves
            .iter()
            .filter_map(|move_| {
                if orbit_move_class_indicies.contains(&move_.move_class_index) {
                    let (perm, ori) = move_.puzzle_state.orbit_bytes(orbit_identifier, orbit_def);
                    Some(O::from_orbit_transformation_unchecked(perm, ori, orbit_def))
                } else {
                    None
                }
            })
            .collect_vec();

        let mut orbit_result = orbit_solved.clone();

        let mut multi_bv = O::new_multi_bv(orbit_def);
        let mut depth = 0;
        let mut vacant_entry_count = entry_count;

        // TODO: multithreading
        // TODO: replace first few with IDDFS
        while let Some(depth_heuristic) = OrbitPruneHeuristic::occupied(depth) {
            let mut exact_orbit_hash = 0;
            let old = vacant_entry_count;
            for perm in (0..piece_count).permutations(piece_count as usize) {
                for ori in repeat_n(0..orbit_def.orientation_count.get(), piece_count as usize)
                    .multi_cartesian_product()
                    // TODO more efficient way than filtering and this overflows too
                    .filter(|ori| {
                        ori.iter()
                            .sum::<u8>()
                            .rem_euclid(orbit_def.orientation_count.get())
                            == 0
                    })
                {
                    if depth != 0
                        && table
                            .storage_backend
                            .heuristic_hash(exact_orbit_hash)
                            .get_occupied()
                            != Some(depth - 1)
                    {
                        exact_orbit_hash += 1;
                        continue;
                    }

                    let curr_state = O::from_orbit_transformation_unchecked(&perm, &ori, orbit_def);
                    if depth == 0 {
                        if curr_state.induces_sorted_orbit_cycle_type(
                            sorted_orbit_cycle_type,
                            orbit_def,
                            multi_bv.reusable_ref(),
                        ) {
                            table
                                .storage_backend
                                .set_heuristic_hash(exact_orbit_hash, depth_heuristic);
                            vacant_entry_count -= 1;
                        }
                        exact_orbit_hash += 1;
                        continue;
                    }

                    for move_ in &orbit_moves {
                        orbit_result.replace_compose(&curr_state, move_, orbit_def);
                        let new_hash = orbit_result.exact_hasher(orbit_def);
                        if table.storage_backend.heuristic_hash(new_hash).is_vacant() {
                            table
                                .storage_backend
                                .set_heuristic_hash(new_hash, depth_heuristic);
                            vacant_entry_count -= 1;
                        }
                    }
                    exact_orbit_hash += 1;
                }
            }
            eprintln!("Depth {depth}: {} filled", old - vacant_entry_count);
            if vacant_entry_count == 0 {
                assert_eq!(exact_orbit_hash, entry_count);
                break;
            }
            depth += 1;
        }
        Ok((table, used_size_bytes))
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.storage_backend.permissible_heuristic_hash(
            puzzle_state.exact_hasher_orbit(self.orbit_identifier, self.orbit_def),
        )
    }
}

impl<P: PuzzleState> OrbitPruningTable<P> for CycleTypeOrbitPruningTable {
    fn try_generate(
        generate_meta: OrbitPruningTableGenerationMeta<P>,
    ) -> Result<
        (CycleTypeOrbitPruningTable, usize),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<P>,
        ),
    > {
        todo!();
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        let hash = todo!();
    }
}

impl<P: PuzzleState> OrbitPruningTable<P> for ZeroOrbitTable {
    fn try_generate(
        _generate_meta: OrbitPruningTableGenerationMeta<P>,
    ) -> Result<
        (ZeroOrbitTable, usize),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<P>,
        ),
    > {
        Ok((ZeroOrbitTable, 0))
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

impl<P: PuzzleState> PruningTables<P> for ZeroTable<P> {
    type GenerateMetas<'a>
        = ()
    where
        P: 'a;
    type GenerateError = ();

    fn try_generate((): ()) -> Result<ZeroTable<P>, ()> {
        Ok(ZeroTable(std::marker::PhantomData))
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::phase2::puzzle::{cube3::Cube3, random_3x3_state};
    use puzzle_geometry::ksolve::KPUZZLE_3X3;

    #[test]
    fn test_orbit_prune_heuristic_invariants() {
        let vacant = OrbitPruneHeuristic::vacant();
        assert!(vacant.is_vacant());
        assert_eq!(vacant.get_occupied(), None);

        let occupied = OrbitPruneHeuristic::occupied(5).unwrap();
        assert!(!occupied.is_vacant());
        assert_eq!(occupied.get_occupied(), Some(5));

        let occupied = OrbitPruneHeuristic::occupied(255);
        assert!(occupied.is_none());
    }

    #[test]
    fn test_exact_uncompressed_storage_backend() {
        let mut storage =
            UncompressedStorageBackend::<true>::initialize_from_meta(MaxSizeBytes(100));

        storage.set_heuristic_hash(5, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(5), 3);

        assert_eq!(storage.permissible_heuristic_hash(6), 0);
        storage.commit_depth_traversed(4);
        assert_eq!(storage.permissible_heuristic_hash(6), 4);
        assert_eq!(storage.permissible_heuristic_hash(5), 3);
    }

    #[test]
    fn test_approximate_uncompressed_storage_backend() {
        let mut storage =
            UncompressedStorageBackend::<false>::initialize_from_meta(MaxSizeBytes(100));

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 3);

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(2).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 2);
    }

    #[test]
    fn test_zero_orbit_tables() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let solved = cube3_def.new_solved_state();
        let u_move = cube3_def.find_move("U").unwrap();
        let identity_cycle_type = [vec![], vec![]];

        let generate_meta = OrbitPruningTableGenerationMeta {
            puzzle_def: &cube3_def,
            sorted_orbit_cycle_type: &[],
            orbit_def: cube3_def.sorted_orbit_defs[0],
            orbit_identifier: 0,
            max_size_bytes: 0,
        };
        let (zero_orbit_table, _) = ZeroOrbitTable::try_generate(generate_meta).unwrap();
        assert_eq!(zero_orbit_table.permissible_heuristic(&solved), 0);
        assert_eq!(
            zero_orbit_table.permissible_heuristic(&u_move.puzzle_state),
            0
        );

        let generate_metas = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &identity_cycle_type,
            vec![
                (OrbitPruningTableTy::Exact, StorageBackendTy::Zero),
                (OrbitPruningTableTy::Zero, StorageBackendTy::Tans),
            ],
            0,
        )
        .unwrap();
        let orbit_tables = OrbitPruningTables::try_generate(generate_metas).unwrap();

        assert_eq!(orbit_tables.permissible_heuristic(&solved), 0);
        assert_eq!(orbit_tables.permissible_heuristic(&u_move.puzzle_state), 0);
    }

    #[test]
    fn test_zero_table() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let zero_table = ZeroTable::try_generate(()).unwrap();

        let random_state = random_3x3_state(&cube3_def, &cube3_def.new_solved_state());
        assert_eq!(zero_table.permissible_heuristic(&random_state), 0);
    }

    #[test]
    fn test_not_supported_table_type() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let identity_cycle_type = [vec![], vec![]];
        let generate_metas = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &identity_cycle_type,
            vec![
                (OrbitPruningTableTy::CycleType, StorageBackendTy::Tans),
                (OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed),
            ],
            0,
        );
        assert!(matches!(
            generate_metas,
            Err(TableTypeInstantiationError::NotSupported(
                OrbitPruningTableTy::CycleType,
                StorageBackendTy::Tans
            ))
        ));
    }

    // #[test]
    // fn test_custom_orientation_index() {
    //     let k = 8;
    //     for orientation_count in 1..=4 {
    //         for (i, orients) in repeat_n(0..orientation_count, k)
    //             .multi_cartesian_product()
    //             .filter(|p| p.iter().sum::<i8>().rem_euclid(orientation_count) == 0)
    //             .enumerate()
    //         {
    //             let left = get_index_of_orientation(&orients, orientation_count as u8);
    //             let right = i as u16;
    //             assert_eq!(left, right);
    //         }
    //     }
    // }

    #[test]
    fn test_new_orbit_generation_meta() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let identity_cycle_type = [vec![], vec![]];
        let generate_metas =
            OrbitPruningTablesGenerateMeta::new(&cube3_def, &identity_cycle_type, 1000).unwrap();
        assert_eq!(generate_metas.max_size_bytes, 1000);
        assert!(generate_metas.maybe_table_types.is_none());

        assert!(matches!(
            OrbitPruningTablesGenerateMeta::new_with_table_types(
                &cube3_def,
                &identity_cycle_type,
                vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed)],
                1000,
            ),
            Err(TableTypeInstantiationError::InvalidTableTypesLength {
                expected: _,
                actual: _
            })
        ));

        OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &identity_cycle_type,
            vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed); 2],
            1000,
        )
        .unwrap();
    }

    #[test]
    fn test_max_bytes_cannot_be_generated() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let identity_cycle_type = [vec![], vec![]];
        let generate_metas = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &identity_cycle_type,
            vec![
                (OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed),
                (OrbitPruningTableTy::Zero, StorageBackendTy::Zero),
            ],
            88_179_839,
        )
        .unwrap();

        let orbit_tables = OrbitPruningTables::try_generate(generate_metas);
        assert!(matches!(
            orbit_tables,
            Err(OrbitPruningTableGenerationError::NotBigEnough)
        ));
    }

    #[test]
    fn test_wip() {
        return;
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let identity_cycle_type = [vec![], vec![]];
        let generate_metas = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &identity_cycle_type,
            vec![
                (OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed),
                (OrbitPruningTableTy::Zero, StorageBackendTy::Zero),
            ],
            88_179_840,
        )
        .unwrap();
        let orbit_tables = OrbitPruningTables::try_generate(generate_metas).unwrap();
        assert_eq!(orbit_tables.orbit_pruning_tables.len(), 2);
        assert_eq!(
            orbit_tables.orbit_pruning_tables[0]
                .permissible_heuristic(&cube3_def.new_solved_state()),
            0
        );
        // println!(
        //     "{:?}",
        //     orbit_tables.orbit_pruning_tables[1]
        // )
        // write the bytes of orbit_tables.orbit_pruning_tables[0] to a file
        // use std::fs::File;
        // let mut file = File::create("orbit_tables.bin").unwrap();
        // // bincode::serialize_into(&mut file, &orbit_tables).unwrap();
        // bincode::encode_to_vec(
        //     &orbit_tables.orbit_pruning_tables[0],
        //     bincode::config::standard(),
        // )
        // .unwrap();
        // // write variable to file
        // let mut file = File::create("orbit_tables.bin").unwrap();
        // bincode::serialize_into(&mut file, &orbit_tables).unwrap();
        // // read variable from file
        // let mut file = File::open("orbit_tables.bin").unwrap();
        // let orbit_tables: OrbitPruningTables<Cube3> =
        //     bincode::deserialize_from(&mut file).unwrap();
    }
    // #[test]
    // fn test_exact_orbit_hasher_only_hashes_orbit() {
    //     let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
    //     let solved = cube3_def.new_solved_state();
    //     let mut result_1 = solved.clone();
    //     let mut result_2 = solved.clone();
    //     let u_move = cube3_def.find_move("U").unwrap();

    //     let exact_corners_pruning_table =
    //         ExactOrbitPruningTable::<UncompressedStorageBackend<true>> {
    //             storage_backend: UncompressedStorageBackend::initialize_from_meta(MaxEntries(100)),
    //             orbit_def: cube3_def.sorted_orbit_defs[0],
    //             orbit_identifier: 0,
    //         };

    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&solved), 0);
    //     result_1.replace_compose(&solved, &u_move.puzzle_state, &cube3_def.sorted_orbit_defs);
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         24476904
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         57868020
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         67775130
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_2), 0);

    //     // shortest 11 cycle alg
    //     result_1 = apply_moves(&cube3_def, &solved, "U R U F L R' U' R' F' D'", 1);

    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         24476904
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         57868020
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         67775130
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);

    //     assert_ne!(solved, result_1);
    // }
}
