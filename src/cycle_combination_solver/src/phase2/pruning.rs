//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use super::puzzle::{PuzzleDef, PuzzleState};

// Trait declarations

pub trait PruningTables<P: PuzzleState> {
    type GenerateMeta;

    fn generate(generate_meta: Self::GenerateMeta) -> Self;
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

/// A trait for a pruning table storage backend
pub trait StorageBackend<const EXACT: bool> {
    type InitializationMeta: From<u64>;

    fn initialize_from_meta(intialization_meta: Self::InitializationMeta) -> Self;
    fn permissible_heuristic_hash(&self, hash: u64) -> u8;
    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic);
    fn commit_depth_traversed(&mut self, depth_traversed: u8);
}

/// A trait for a pruning table acting on a single orbit.
trait OrbitPruningTable<'a, P: PuzzleState> {
    fn generate(
        puzzle_def: &'a PuzzleDef<P>,
        orbit_index: usize,
        max_size_bytes: u64,
    ) -> (Self, u64)
    where
        Self: Sized;

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64;

    /// Implementors are expected to forward the call to their storage backend.
    /// Interestingly, the alternative way of requiring a storage backend getter
    /// needs a trait object which is slow so this seems to be the best way.
    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8;

    /// This convenience function is a performance optimization that avoids two
    /// otherwise dynamic dispatches.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.permissible_heuristic_hash_outer(self.hash_puzzle_state(puzzle_state))
    }
}

// Data structure declarations

pub struct OrbitPruningTables<'a, P: PuzzleState> {
    orbit_pruning_tables: Box<[Box<dyn OrbitPruningTable<'a, P> + 'a>]>,
}

pub struct OrbitPruningTablesGenerateMeta<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    max_size_bytes: u64,
    table_types: Option<Vec<(OrbitPruningTableTy, StorageBackendTy)>>,
}

pub struct UncompressedStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    depth_traversed: u8,
}

struct TANSStorageEncodingTable {
    // silly things here
}

pub struct TANSStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    counts_by_depth: Box<[u64]>,
    encoding_tables: Box<[TANSStorageEncodingTable]>,
}

/// This type isn't actually entirely useless; I will use it for tables that
/// have no remaining allocable space (by the max_size_bytes option).
pub struct ZeroStorageBackend;

pub struct ApproximateOrbitPruningTable<'a, P: PuzzleState, S: StorageBackend<false>> {
    storage_backend: S,
    puzzle_def: &'a PuzzleDef<P>,
    orbit_index: usize,
}

pub struct ExactOrbitPruningTable<'a, P: PuzzleState, S: StorageBackend<true>> {
    storage_backend: S,
    puzzle_def: &'a PuzzleDef<P>,
    orbit_index: usize,
}

pub struct CycleTypeOrbitPruningTable<'a, P: PuzzleState, S: StorageBackend<true>> {
    storage_backend: S,
    puzzle_def: &'a PuzzleDef<P>,
    orbit_index: usize,
}

#[derive(Default, PartialEq, Debug, Clone, Copy)]
pub enum OrbitPruningTableTy {
    Approximate,
    Exact,
    CycleType,
    #[default]
    Dynamic,
}

#[derive(Default, PartialEq, Debug, Clone, Copy)]
pub enum StorageBackendTy {
    Uncompressed,
    Tans,
    Zero,
    #[default]
    Dynamic,
}

pub struct ZeroTable<P: PuzzleState>(std::marker::PhantomData<P>);

// Implementations

use private::*;
mod private {
    #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
    pub struct OrbitPruneHeuristic(u8);

    impl OrbitPruneHeuristic {
        const VACANT: u8 = u8::MAX;

        pub fn vacant() -> OrbitPruneHeuristic {
            OrbitPruneHeuristic(Self::VACANT)
        }

        pub fn occupied(depth_traversed: u8) -> Option<OrbitPruneHeuristic> {
            if depth_traversed == Self::VACANT {
                None
            } else {
                Some(OrbitPruneHeuristic(depth_traversed))
            }
        }

        pub fn is_vacant(&self) -> bool {
            self.0 == Self::VACANT
        }

        pub fn get_occupied(&self) -> Option<u8> {
            if self.is_vacant() { None } else { Some(self.0) }
        }
    }

    pub struct MaxSizeBytes(pub u64);
    pub struct MaxEntires(pub usize);

    impl From<u64> for MaxSizeBytes {
        fn from(value: u64) -> Self {
            MaxSizeBytes(value)
        }
    }

    impl From<u64> for MaxEntires {
        fn from(value: u64) -> Self {
            MaxEntires(value as usize)
        }
    }
}

pub struct NullMeta;

impl From<u64> for NullMeta {
    fn from(_: u64) -> Self {
        NullMeta
    }
}

impl<'a, P: PuzzleState> OrbitPruningTablesGenerateMeta<'a, P> {
    pub fn new(puzzle_def: &'a PuzzleDef<P>, max_size_bytes: u64) -> Self {
        OrbitPruningTablesGenerateMeta {
            puzzle_def,
            max_size_bytes,
            table_types: None,
        }
    }

    /// Exactly the same as `from` but with a list of forced table types. Panics
    /// if the table types are a different length than the number of orbits. I
    /// expect to always .unwrap() this function in tests, so it might as well
    /// be unrecoverable.
    pub fn new_with_table_types(
        puzzle_def: &'a PuzzleDef<P>,
        max_size_bytes: u64,
        table_types: Vec<(OrbitPruningTableTy, StorageBackendTy)>,
    ) -> Self {
        assert_eq!(
            table_types.len(),
            puzzle_def.sorted_orbit_defs.len(),
            "Table types length must match the number of orbits."
        );
        OrbitPruningTablesGenerateMeta {
            puzzle_def,
            max_size_bytes,
            table_types: Some(table_types),
        }
    }
}

impl<'a, P: PuzzleState + 'a> PruningTables<P> for OrbitPruningTables<'a, P> {
    type GenerateMeta = OrbitPruningTablesGenerateMeta<'a, P>;

    fn generate(generate_meta: OrbitPruningTablesGenerateMeta<'a, P>) -> OrbitPruningTables<'a, P> {
        let mut orbit_pruning_tables = vec![];
        let mut remaining_size = generate_meta.max_size_bytes;
        // Already sorted by (piece count, orientation) which is (usually) from
        // smallest to largest which makes this work. This essentially populates
        // the smallest pruning tables while dynamically updating how much space
        // is reserved for the remaining orbit tables.
        for orbit_index in 0..generate_meta.puzzle_def.sorted_orbit_defs.len() {
            let unprocessed_orbits_count =
                generate_meta.puzzle_def.sorted_orbit_defs.len() - orbit_index;
            let (orbit_pruning_table, used_size) = choose_pruning_table(
                generate_meta.puzzle_def,
                generate_meta
                    .table_types
                    .as_ref()
                    .map(|table_types| table_types[orbit_index]),
                orbit_index,
                remaining_size / unprocessed_orbits_count as u64,
            );
            remaining_size -= used_size;
            orbit_pruning_tables.push(orbit_pruning_table);
        }

        OrbitPruningTables {
            orbit_pruning_tables: orbit_pruning_tables.into_boxed_slice(),
        }
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.orbit_pruning_tables
            .iter()
            .fold(0, |best_bound, orbit_pruning_table| {
                best_bound.max(orbit_pruning_table.permissible_heuristic(puzzle_state))
            })
    }
}

/// Choose the appropriate pruning table based on the orbit definition and size.
/// Returns a pruning table trait object along with its size in bytes.
fn choose_pruning_table<P: PuzzleState>(
    puzzle_def: &PuzzleDef<P>,
    table_type: Option<(OrbitPruningTableTy, StorageBackendTy)>,
    orbit_index: usize,
    max_size_bytes: u64,
) -> (Box<dyn OrbitPruningTable<P> + '_>, u64) {
    macro_rules! table {
        ($a:ident, $b:ident, $c:ident) => {{
            let (table, used_size) =
                $a::<P, $b<{ $c }>>::generate(puzzle_def, orbit_index, max_size_bytes);
            return (Box::new(table), used_size);
        }};

        ($a:ident, $b:ident) => {{
            let (table, used_size) = $a::<P, $b>::generate(puzzle_def, orbit_index, max_size_bytes);
            return (Box::new(table), used_size);
        }};
    }

    if let Some((table_type, storage_backend_type)) = table_type {
        match (table_type, storage_backend_type) {
            (OrbitPruningTableTy::Approximate, StorageBackendTy::Uncompressed) => {
                table!(
                    ApproximateOrbitPruningTable,
                    UncompressedStorageBackend,
                    false
                )
            }
            (OrbitPruningTableTy::Approximate, StorageBackendTy::Tans) => {
                table!(ApproximateOrbitPruningTable, TANSStorageBackend, false)
            }
            (OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed) => {
                table!(ExactOrbitPruningTable, UncompressedStorageBackend, true)
            }
            (OrbitPruningTableTy::Exact, StorageBackendTy::Tans) => {
                table!(ExactOrbitPruningTable, TANSStorageBackend, true)
            }
            (OrbitPruningTableTy::Exact, StorageBackendTy::Zero)
            | (OrbitPruningTableTy::Approximate, StorageBackendTy::Zero) => {
                table!(ExactOrbitPruningTable, ZeroStorageBackend)
            }
            (OrbitPruningTableTy::CycleType, StorageBackendTy::Uncompressed) => {
                table!(CycleTypeOrbitPruningTable, UncompressedStorageBackend, true)
            }
            (OrbitPruningTableTy::CycleType, StorageBackendTy::Tans) => {
                table!(CycleTypeOrbitPruningTable, TANSStorageBackend, true)
            }
            (OrbitPruningTableTy::CycleType, StorageBackendTy::Zero) => {
                table!(CycleTypeOrbitPruningTable, ZeroStorageBackend)
            }
            (OrbitPruningTableTy::Dynamic, StorageBackendTy::Dynamic) => (),
            // might remove this
            (OrbitPruningTableTy::Dynamic, _) => {
                panic!("Dynamic table type must be paired with a dynamic storage backend type.")
            }
            (_, StorageBackendTy::Dynamic) => {
                panic!("Dynamic storage backend type must be paired with a dynamic table type.")
            }
        }
    }

    todo!();
}

impl<const EXACT: bool> StorageBackend<EXACT> for UncompressedStorageBackend<EXACT> {
    type InitializationMeta = MaxEntires;

    fn initialize_from_meta(max_entries: MaxEntires) -> UncompressedStorageBackend<EXACT> {
        let max_entries = max_entries.0;
        let data = vec![OrbitPruneHeuristic::vacant(); max_entries].into_boxed_slice();
        UncompressedStorageBackend {
            data,
            depth_traversed: 0,
        }
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        self.data[hash as usize]
            .get_occupied()
            .unwrap_or(self.depth_traversed)
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            self.data[hash as usize] = orbit_prune_heuristic;
        } else {
            self.data[hash as usize] = self.data[hash as usize].min(orbit_prune_heuristic);
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        self.depth_traversed = depth_traversed;
    }
}

impl<const EXACT: bool> StorageBackend<EXACT> for TANSStorageBackend<EXACT> {
    type InitializationMeta = MaxSizeBytes;

    fn initialize_from_meta(max_size_bytes: MaxSizeBytes) -> TANSStorageBackend<EXACT> {
        let max_size_bytes = max_size_bytes.0;
        todo!();
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        todo!();
    }
}

impl StorageBackend<true> for ZeroStorageBackend {
    type InitializationMeta = NullMeta;

    fn initialize_from_meta(_: NullMeta) -> ZeroStorageBackend {
        ZeroStorageBackend
    }

    fn permissible_heuristic_hash(&self, _hash: u64) -> u8 {
        0
    }

    fn set_heuristic_hash(&mut self, _hash: u64, _orbit_prune_heuristic: OrbitPruneHeuristic) {}

    fn commit_depth_traversed(&mut self, _depth_traversed: u8) {}
}

impl<'a, P: PuzzleState, S: StorageBackend<false>> OrbitPruningTable<'a, P>
    for ApproximateOrbitPruningTable<'a, P, S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size_bytes: u64,
    ) -> (ApproximateOrbitPruningTable<P, S>, u64) {
        todo!();
    }

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64 {
        fxhash::hash64(
            &puzzle_state
                .orbit_bytes_by_index(self.orbit_index, &self.puzzle_def.sorted_orbit_defs),
        )
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<'a, P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<'a, P>
    for ExactOrbitPruningTable<'a, P, S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size_bytes: u64,
    ) -> (ExactOrbitPruningTable<P, S>, u64) {
        // TODO: temporary just to get poc working
        (
            ExactOrbitPruningTable {
                storage_backend: S::initialize_from_meta(max_size_bytes.into()),
                puzzle_def,
                orbit_index,
            },
            0,
        )
        // todo!()
    }

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64 {
        // todo!()
        0
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<'a, P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<'a, P>
    for CycleTypeOrbitPruningTable<'a, P, S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size_bytes: u64,
    ) -> (CycleTypeOrbitPruningTable<P, S>, u64) {
        todo!();
    }

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64 {
        todo!();
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<P: PuzzleState> PruningTables<P> for ZeroTable<P> {
    type GenerateMeta = NullMeta;

    fn generate(_: NullMeta) -> ZeroTable<P> {
        ZeroTable(std::marker::PhantomData)
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::phase2::puzzle::{cube3::Cube3, random_3x3_state};
    use puzzle_geometry::ksolve::KPUZZLE_3X3;

    #[test]
    fn test_orbit_prune_heuristic_invariants() {
        let vacant = OrbitPruneHeuristic::vacant();
        assert!(vacant.is_vacant());
        assert_eq!(vacant.get_occupied(), None);

        let occupied = OrbitPruneHeuristic::occupied(5).unwrap();
        assert!(!occupied.is_vacant());
        assert_eq!(occupied.get_occupied(), Some(5));

        let occupied = OrbitPruneHeuristic::occupied(255);
        assert!(occupied.is_none());
    }

    #[test]
    fn test_exact_uncompressed_storage_backend() {
        let mut storage = UncompressedStorageBackend::<true>::initialize_from_meta(MaxEntires(100));

        storage.set_heuristic_hash(5, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(5), 3);

        assert_eq!(storage.permissible_heuristic_hash(6), 0);
        storage.commit_depth_traversed(4);
        assert_eq!(storage.permissible_heuristic_hash(6), 4);
        assert_eq!(storage.permissible_heuristic_hash(5), 3);
    }

    #[test]
    fn test_approximate_uncompressed_storage_backend() {
        let mut storage =
            UncompressedStorageBackend::<false>::initialize_from_meta(MaxEntires(100));

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 3);

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(2).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 2);
    }

    #[test]
    fn test_zero_storage_backend_gives_zero() {
        let storage = ZeroStorageBackend::initialize_from_meta(NullMeta);
        assert_eq!(storage.permissible_heuristic_hash(0), 0);
        assert_eq!(storage.permissible_heuristic_hash(1), 0);
        assert_eq!(storage.permissible_heuristic_hash(2), 0);
    }

    #[test]
    fn test_zero_table() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let zero_table = ZeroTable::generate(NullMeta);

        let random_state = random_3x3_state(&cube3_def, &cube3_def.new_solved_state());
        assert_eq!(zero_table.permissible_heuristic(&random_state), 0);
    }

    #[test]
    fn test_table_type_defaults() {
        assert_eq!(OrbitPruningTableTy::Dynamic, OrbitPruningTableTy::default());
        assert_eq!(StorageBackendTy::Dynamic, StorageBackendTy::default());
    }

    #[test]
    fn test_new_orbit_generation_meta() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let generate_meta = OrbitPruningTablesGenerateMeta::new(&cube3_def, 1000);
        assert_eq!(generate_meta.max_size_bytes, 1000);
        assert!(generate_meta.table_types.is_none());

        assert!(
            std::panic::catch_unwind(|| OrbitPruningTablesGenerateMeta::new_with_table_types(
                &cube3_def,
                1000,
                vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed)],
            ))
            .is_err()
        );

        OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            1000,
            vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed); 2],
        );
    }

    #[test]
    fn test_zero_orbit_tables() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let generate_meta = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            0,
            vec![
                (OrbitPruningTableTy::Exact, StorageBackendTy::Zero),
                (OrbitPruningTableTy::Exact, StorageBackendTy::Zero),
            ],
        );
        let orbit_tables = OrbitPruningTables::generate(generate_meta);

        assert_eq!(
            orbit_tables.permissible_heuristic(&cube3_def.new_solved_state()),
            0
        );
    }
}
