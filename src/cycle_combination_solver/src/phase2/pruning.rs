//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use super::puzzle::{OrbitDef, OrientedPartition, PuzzleDef, PuzzleState};
use std::{fmt, iter::repeat_n, num::NonZeroU8};

// Trait declarations

pub trait PruningTables<P: PuzzleState> {
    type GenerateMeta<'a>
    where
        P: 'a;

    fn generate(generate_meta: Self::GenerateMeta<'_>) -> Self;
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

/// A trait for a pruning table storage backend
pub trait StorageBackend<const EXACT: bool> {
    type InitializationMeta: From<u64>;

    fn initialize_from_meta(intialization_meta: Self::InitializationMeta) -> Self;
    fn permissible_heuristic_hash(&self, hash: u64) -> u8;
    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic;
    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic);
    fn commit_depth_traversed(&mut self, depth_traversed: u8);
}

/// A trait for a pruning table acting on a single orbit.
trait OrbitPruningTable<P: PuzzleState> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (Self, u64)
    where
        Self: Sized;

    fn hash_orbit_state(&self, puzzle_state: &P) -> u64;

    /// Implementors are expected to forward the call to their storage backend.
    /// Interestingly, the alternative way of requiring a storage backend getter
    /// needs a trait object which is slow so this seems to be the best way.
    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8;

    /// This convenience function is a performance optimization that avoids two
    /// otherwise dynamic dispatches.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.permissible_heuristic_hash_outer(self.hash_orbit_state(puzzle_state))
    }
}

// Data structure declarations

pub struct OrbitPruningTables<P: PuzzleState> {
    orbit_pruning_tables: Box<[Box<dyn OrbitPruningTable<P>>]>,
}

pub struct OrbitPruningTablesGenerateMeta<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    sorted_cycle_type: &'a [OrientedPartition],
    max_size_bytes: u64,
    table_types: Option<Vec<(OrbitPruningTableTy, StorageBackendTy)>>,
}

pub struct UncompressedStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    depth_traversed: u8,
}

struct TANSStorageEncodingTable {
    // silly things here
}

pub struct TANSStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    counts_by_depth: Box<[u64]>,
    encoding_tables: Box<[TANSStorageEncodingTable]>,
}

pub struct ApproximateOrbitPruningTable<S: StorageBackend<false>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

pub struct ExactOrbitPruningTable<S: StorageBackend<true>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

pub struct CycleTypeOrbitPruningTable<S: StorageBackend<true>> {
    storage_backend: S,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
}

/// This type isn't actually entirely useless; I will use it for tables that
/// have no remaining allocable space (by the max_size_bytes option).
pub struct ZeroOrbitTable;

#[derive(Default, PartialEq, Debug, Clone, Copy)]
pub enum OrbitPruningTableTy {
    Approximate,
    Exact,
    CycleType,
    Zero,
    #[default]
    Dynamic,
}

#[derive(Default, PartialEq, Debug, Clone, Copy)]
pub enum StorageBackendTy {
    Uncompressed,
    Tans,
    Zero,
    #[default]
    Dynamic,
}

pub struct ZeroTable<P: PuzzleState>(std::marker::PhantomData<P>);

// Implementations

use itertools::Itertools;
use private::*;
mod private {
    #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
    pub struct OrbitPruneHeuristic(u8);

    impl OrbitPruneHeuristic {
        const VACANT: u8 = u8::MAX;

        pub fn vacant() -> OrbitPruneHeuristic {
            OrbitPruneHeuristic(Self::VACANT)
        }

        pub fn occupied(depth_traversed: u8) -> Option<OrbitPruneHeuristic> {
            if depth_traversed == Self::VACANT {
                None
            } else {
                Some(OrbitPruneHeuristic(depth_traversed))
            }
        }

        pub fn is_vacant(&self) -> bool {
            self.0 == Self::VACANT
        }

        pub fn get_occupied(&self) -> Option<u8> {
            if self.is_vacant() { None } else { Some(self.0) }
        }
    }
}

pub struct MaxSizeBytes(pub u64);
pub struct MaxEntires(pub usize);
pub struct NullMeta;

impl From<u64> for MaxSizeBytes {
    fn from(value: u64) -> Self {
        MaxSizeBytes(value)
    }
}

impl From<u64> for MaxEntires {
    fn from(value: u64) -> Self {
        MaxEntires(value as usize)
    }
}

impl From<u64> for NullMeta {
    fn from(_: u64) -> Self {
        NullMeta
    }
}

#[derive(Debug)]
pub struct TableTypeError(String);

impl fmt::Display for TableTypeError {
    fn fmt(&self, f: &mut fmt::Formatter<'_>) -> fmt::Result {
        write!(f, "Table type error: {}", self.0)
    }
}

impl<'a, P: PuzzleState> OrbitPruningTablesGenerateMeta<'a, P> {
    pub fn new(
        puzzle_def: &'a PuzzleDef<P>,
        sorted_cycle_type: &'a [OrientedPartition],
        max_size_bytes: u64,
    ) -> Self {
        OrbitPruningTablesGenerateMeta {
            puzzle_def,
            sorted_cycle_type,
            max_size_bytes,
            table_types: None,
        }
    }

    pub fn new_with_table_types(
        puzzle_def: &'a PuzzleDef<P>,
        sorted_cycle_type: &'a [OrientedPartition],
        max_size_bytes: u64,
        table_types: Vec<(OrbitPruningTableTy, StorageBackendTy)>,
    ) -> Result<Self, TableTypeError> {
        if table_types.len() == puzzle_def.sorted_orbit_defs.len() {
            Ok(OrbitPruningTablesGenerateMeta {
                puzzle_def,
                sorted_cycle_type,
                max_size_bytes,
                table_types: Some(table_types),
            })
        } else {
            Err(TableTypeError(format!(
                "Table types length {} does not match orbit definitions length {}",
                table_types.len(),
                puzzle_def.sorted_orbit_defs.len()
            )))
        }
    }
}

impl<P: PuzzleState> PruningTables<P> for OrbitPruningTables<P> {
    type GenerateMeta<'a>
        = OrbitPruningTablesGenerateMeta<'a, P>
    where
        P: 'a;

    fn generate(generate_meta: OrbitPruningTablesGenerateMeta<P>) -> OrbitPruningTables<P> {
        let mut orbit_pruning_tables = vec![];
        let mut remaining_size = generate_meta.max_size_bytes;
        // Already sorted by (piece count, orientation) which is (usually) from
        // smallest to largest which makes this work. This essentially populates
        // the smallest pruning tables while dynamically updating how much space
        // is reserved for the remaining orbit tables.
        let mut orbit_identifier = 0;
        for orbit_index in 0..generate_meta.puzzle_def.sorted_orbit_defs.len() {
            let orbit_def = generate_meta.puzzle_def.sorted_orbit_defs[orbit_index];
            let sorted_orbit_cycle_type = &generate_meta.sorted_cycle_type[orbit_index];
            let unprocessed_orbits_count =
                generate_meta.puzzle_def.sorted_orbit_defs.len() - orbit_index;
            let (orbit_pruning_table, used_size) = choose_pruning_table(
                generate_meta.puzzle_def,
                generate_meta
                    .table_types
                    .as_ref()
                    .map(|table_types| table_types[orbit_index]),
                sorted_orbit_cycle_type,
                orbit_def,
                orbit_identifier,
                remaining_size / unprocessed_orbits_count as u64,
            );
            remaining_size -= used_size;
            orbit_identifier = P::next_orbit_identifer(orbit_identifier, orbit_def);
            orbit_pruning_tables.push(orbit_pruning_table);
        }

        OrbitPruningTables {
            orbit_pruning_tables: orbit_pruning_tables.into_boxed_slice(),
        }
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.orbit_pruning_tables
            .iter()
            .fold(0, |best_bound, orbit_pruning_table| {
                best_bound.max(orbit_pruning_table.permissible_heuristic(puzzle_state))
            })
    }
}

/// Choose the appropriate pruning table based on the orbit definition and size.
/// Returns a pruning table trait object along with its size in bytes.
fn choose_pruning_table<P: PuzzleState>(
    puzzle_def: &PuzzleDef<P>,
    table_type: Option<(OrbitPruningTableTy, StorageBackendTy)>,
    sorted_orbit_cycle_type: &OrientedPartition,
    orbit_def: OrbitDef,
    orbit_identifier: usize,
    max_size_bytes: u64,
) -> (Box<dyn OrbitPruningTable<P>>, u64) {
    macro_rules! table {
        ($a:ident, $b:ident, $c:ident) => {{
            let (table, used_size) = $a::<$b<{ $c }>>::generate(
                puzzle_def,
                sorted_orbit_cycle_type,
                orbit_def,
                orbit_identifier,
                max_size_bytes,
            );
            return (Box::new(table), used_size);
        }};

        ($a:ident) => {{
            let (table, used_size) = $a::generate(
                puzzle_def,
                sorted_orbit_cycle_type,
                orbit_def,
                orbit_identifier,
                max_size_bytes,
            );
            return (Box::new(table), used_size);
        }};
    }

    if let Some((table_type, storage_backend_type)) = table_type {
        match (table_type, storage_backend_type) {
            (OrbitPruningTableTy::Approximate, StorageBackendTy::Uncompressed) => {
                table!(
                    ApproximateOrbitPruningTable,
                    UncompressedStorageBackend,
                    false
                )
            }
            (OrbitPruningTableTy::Approximate, StorageBackendTy::Tans) => {
                table!(ApproximateOrbitPruningTable, TANSStorageBackend, false)
            }
            (OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed) => {
                table!(ExactOrbitPruningTable, UncompressedStorageBackend, true)
            }
            (OrbitPruningTableTy::Exact, StorageBackendTy::Tans) => {
                table!(ExactOrbitPruningTable, TANSStorageBackend, true)
            }
            (OrbitPruningTableTy::CycleType, StorageBackendTy::Uncompressed) => {
                table!(CycleTypeOrbitPruningTable, UncompressedStorageBackend, true)
            }
            (OrbitPruningTableTy::CycleType, StorageBackendTy::Tans) => {
                table!(CycleTypeOrbitPruningTable, TANSStorageBackend, true)
            }
            (OrbitPruningTableTy::Zero, _) | (_, StorageBackendTy::Zero) => {
                table!(ZeroOrbitTable)
            }
            (OrbitPruningTableTy::Dynamic, _) | (_, StorageBackendTy::Dynamic) => (),
        }
    }

    todo!();
}

impl<const EXACT: bool> StorageBackend<EXACT> for UncompressedStorageBackend<EXACT> {
    type InitializationMeta = MaxEntires;

    fn initialize_from_meta(max_entries: MaxEntires) -> UncompressedStorageBackend<EXACT> {
        let max_entries = max_entries.0;
        let data = vec![OrbitPruneHeuristic::vacant(); max_entries].into_boxed_slice();
        UncompressedStorageBackend {
            data,
            depth_traversed: 0,
        }
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        self.heuristic_hash(hash)
            .get_occupied()
            .unwrap_or(self.depth_traversed)
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        self.data[hash as usize]
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            self.data[hash as usize] = orbit_prune_heuristic;
        } else {
            self.data[hash as usize] = self.data[hash as usize].min(orbit_prune_heuristic);
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        self.depth_traversed = depth_traversed;
    }
}

impl<const EXACT: bool> StorageBackend<EXACT> for TANSStorageBackend<EXACT> {
    type InitializationMeta = MaxSizeBytes;

    fn initialize_from_meta(max_size_bytes: MaxSizeBytes) -> TANSStorageBackend<EXACT> {
        let max_size_bytes = max_size_bytes.0;
        todo!();
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        todo!();
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        todo!();
    }
}

impl<P: PuzzleState, S: StorageBackend<false>> OrbitPruningTable<P>
    for ApproximateOrbitPruningTable<S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (ApproximateOrbitPruningTable<S>, u64) {
        todo!();
    }

    fn hash_orbit_state(&self, puzzle_state: &P) -> u64 {
        fxhash::hash64(&puzzle_state.orbit_bytes(self.orbit_identifier, self.orbit_def))
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

// taken from https://stackoverflow.com/a/64424328/12230735
const fn factorial(n: u64) -> Option<u64> {
    match n {
        0 | 1 => Some(1),
        2..=20 => match factorial(n - 1) {
            Some(x) => Some(n * x),
            None => None,
        },
        _ => None,
    }
}

impl<P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<P> for ExactOrbitPruningTable<S> {
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (ExactOrbitPruningTable<S>, u64) {
        let piece_count = orbit_def.piece_count.get();
        assert!(piece_count > 0);
        // TODO: pass as arg
        let mut result = puzzle_def.new_solved_state();
        let entry_count = factorial(piece_count as u64).unwrap()
            * u64::pow(
                orbit_def.orientation_count.get() as u64,
                piece_count as u32 - 1,
            );

        let mut ret = ExactOrbitPruningTable {
            storage_backend: S::initialize_from_meta(max_size_bytes.into()),
            orbit_def,
            orbit_identifier,
        };

        let mut multi_bv = P::new_multi_bv(&puzzle_def.sorted_orbit_defs);
        let mut depth = 0;
        let mut vacant_entry_count = entry_count;
        while let Some(depth_heuristic) = OrbitPruneHeuristic::occupied(depth) {
            for ((exact_perm_hash, perm), (exact_ori_hash, ori)) in (0..piece_count as u64)
                .permutations(piece_count as usize)
                .enumerate()
                .cartesian_product(
                    repeat_n(
                        0..orbit_def.orientation_count.get() as u64,
                        piece_count as usize - 1,
                    )
                    .multi_cartesian_product()
                    .enumerate(),
                )
            {
                // TODO: is caching necessary?
                let exact_orbit_hash = exact_perm_hash as u64
                    * u64::pow(
                        orbit_def.orientation_count.get() as u64,
                        piece_count as u32 - 1,
                    )
                    + exact_ori_hash as u64;

                if depth == 0 {
                    // TODO: if hash induces cycle type
                    if true {
                        ret.storage_backend
                            .set_heuristic_hash(exact_orbit_hash, depth_heuristic);
                        vacant_entry_count -= 1;
                    }
                } else if ret
                    .storage_backend
                    .heuristic_hash(exact_orbit_hash)
                    .get_occupied()
                    == Some(depth - 1)
                {
                    // TODO: special puzzles for representing a single orbit
                    let curr_state: P =
                        P::from_orbit_transformation_unchecked(&perm, &ori, orbit_def);
                    for move_ in &puzzle_def.moves {
                        result.replace_compose(
                            &curr_state,
                            &move_.puzzle_state,
                            &puzzle_def.sorted_orbit_defs,
                        );
                        let new_hash = ret.hash_orbit_state(&result);

                        if ret.storage_backend.heuristic_hash(new_hash).is_vacant() {
                            ret.storage_backend
                                .set_heuristic_hash(new_hash, depth_heuristic);
                            vacant_entry_count -= 1;
                        }
                    }
                }
            }
            if vacant_entry_count == 0 {
                break;
            }
            depth += 1;
        }
        (ret, entry_count)
    }

    fn hash_orbit_state(&self, puzzle_state: &P) -> u64 {
        // puzzle_state.exact_permutation_hash(self.orbit_identifier, self.orbit_def.piece_count)
        let (perm, ori) = puzzle_state.orbit_bytes(self.orbit_identifier, self.orbit_def);
        let piece_count = self.orbit_def.piece_count.get();

        let mut exact_perm_hash = 0;
        for i in 0..piece_count {
            let mut res = 0;
            for j in (i + 1)..piece_count {
                if perm[j as usize] < perm[i as usize] {
                    res += 1;
                }
            }
            exact_perm_hash += res * factorial((piece_count - i - 1) as u64).unwrap();
        }

        let mut exact_ori_hash = 0;
        for i in 0..piece_count - 1 {
            exact_ori_hash += ori[i as usize] as u64;
            if i != piece_count - 2 {
                exact_ori_hash *= self.orbit_def.orientation_count.get() as u64;
            }
        }

        exact_perm_hash
            * u64::pow(
                self.orbit_def.orientation_count.get() as u64,
                piece_count as u32 - 1,
            )
            + exact_ori_hash
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<P>
    for CycleTypeOrbitPruningTable<S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        orbit_def: OrbitDef,
        orbit_identifier: usize,
        max_size_bytes: u64,
    ) -> (CycleTypeOrbitPruningTable<S>, u64) {
        todo!();
    }

    fn hash_orbit_state(&self, puzzle_state: &P) -> u64 {
        todo!();
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<P: PuzzleState> OrbitPruningTable<P> for ZeroOrbitTable {
    fn generate(
        _puzzle_def: &PuzzleDef<P>,
        _sorted_orbit_cycle_type: &[(NonZeroU8, bool)],
        _orbit_def: OrbitDef,
        _orbit_identifier: usize,
        _max_size_bytes: u64,
    ) -> (ZeroOrbitTable, u64) {
        (ZeroOrbitTable, 0)
    }

    fn hash_orbit_state(&self, _puzzle_state: &P) -> u64 {
        0
    }

    fn permissible_heuristic_hash_outer(&self, _hash: u64) -> u8 {
        0
    }
}

impl<P: PuzzleState> PruningTables<P> for ZeroTable<P> {
    type GenerateMeta<'a>
        = NullMeta
    where
        P: 'a;

    fn generate(_: NullMeta) -> ZeroTable<P> {
        ZeroTable(std::marker::PhantomData)
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::phase2::puzzle::{HeapPuzzle, apply_moves, cube3::Cube3, random_3x3_state};
    use puzzle_geometry::ksolve::KPUZZLE_3X3;

    #[test]
    fn test_orbit_prune_heuristic_invariants() {
        let vacant = OrbitPruneHeuristic::vacant();
        assert!(vacant.is_vacant());
        assert_eq!(vacant.get_occupied(), None);

        let occupied = OrbitPruneHeuristic::occupied(5).unwrap();
        assert!(!occupied.is_vacant());
        assert_eq!(occupied.get_occupied(), Some(5));

        let occupied = OrbitPruneHeuristic::occupied(255);
        assert!(occupied.is_none());
    }

    #[test]
    fn test_exact_uncompressed_storage_backend() {
        let mut storage = UncompressedStorageBackend::<true>::initialize_from_meta(MaxEntires(100));

        storage.set_heuristic_hash(5, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(5), 3);

        assert_eq!(storage.permissible_heuristic_hash(6), 0);
        storage.commit_depth_traversed(4);
        assert_eq!(storage.permissible_heuristic_hash(6), 4);
        assert_eq!(storage.permissible_heuristic_hash(5), 3);
    }

    #[test]
    fn test_approximate_uncompressed_storage_backend() {
        let mut storage =
            UncompressedStorageBackend::<false>::initialize_from_meta(MaxEntires(100));

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 3);

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(2).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 2);
    }

    #[test]
    fn test_zero_orbit_table_gives_zero() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let solved = cube3_def.new_solved_state();
        let u_move = cube3_def.find_move("U").unwrap();

        let (storage, _) =
            ZeroOrbitTable::generate(&cube3_def, &[], cube3_def.sorted_orbit_defs[0], 0, 0);
        assert_eq!(storage.permissible_heuristic(&solved), 0);
        assert_eq!(storage.permissible_heuristic(&u_move.puzzle_state), 0);
    }

    #[test]
    fn test_zero_table() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let zero_table = ZeroTable::generate(NullMeta);

        let random_state = random_3x3_state(&cube3_def, &cube3_def.new_solved_state());
        assert_eq!(zero_table.permissible_heuristic(&random_state), 0);
    }

    #[test]
    fn test_table_type_defaults() {
        assert_eq!(OrbitPruningTableTy::Dynamic, OrbitPruningTableTy::default());
        assert_eq!(StorageBackendTy::Dynamic, StorageBackendTy::default());
    }

    #[test]
    fn test_new_orbit_generation_meta() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let generate_meta = OrbitPruningTablesGenerateMeta::new(&cube3_def, &[], 1000);
        assert_eq!(generate_meta.max_size_bytes, 1000);
        assert!(generate_meta.table_types.is_none());

        assert!(
            OrbitPruningTablesGenerateMeta::new_with_table_types(
                &cube3_def,
                &[],
                1000,
                vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed)],
            )
            .is_err()
        );

        OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &[],
            1000,
            vec![(OrbitPruningTableTy::Exact, StorageBackendTy::Uncompressed); 2],
        )
        .unwrap();
    }

    #[test]
    fn test_zero_orbit_tables() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let generate_meta = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            &[],
            0,
            vec![
                (OrbitPruningTableTy::Exact, StorageBackendTy::Zero),
                (OrbitPruningTableTy::Exact, StorageBackendTy::Zero),
            ],
        )
        .unwrap();
        let orbit_tables = OrbitPruningTables::generate(generate_meta);

        assert_eq!(
            orbit_tables.permissible_heuristic(&cube3_def.new_solved_state()),
            0
        );
    }

    #[test]
    fn test_exact_orbit_hasher_only_hashes_orbit() {
        let cube3_def: PuzzleDef<HeapPuzzle> = (&*KPUZZLE_3X3).try_into().unwrap();
        let solved = cube3_def.new_solved_state();
        let mut result_1 = solved.clone();
        let mut result_2 = solved.clone();
        let u_move = cube3_def.find_move("U").unwrap();

        let exact_corners_pruning_table =
            ExactOrbitPruningTable::<UncompressedStorageBackend<true>> {
                storage_backend: UncompressedStorageBackend::initialize_from_meta(MaxEntires(100)),
                orbit_def: cube3_def.sorted_orbit_defs[0],
                orbit_identifier: 0,
            };

        assert_eq!(exact_corners_pruning_table.hash_orbit_state(&solved), 0);
        result_1.replace_compose(&solved, &u_move.puzzle_state, &cube3_def.sorted_orbit_defs);
        assert_eq!(
            exact_corners_pruning_table.hash_orbit_state(&result_1),
            24476904
        );
        result_2.replace_compose(
            &result_1,
            &u_move.puzzle_state,
            &cube3_def.sorted_orbit_defs,
        );
        assert_eq!(
            exact_corners_pruning_table.hash_orbit_state(&result_2),
            57868020
        );
        result_1.replace_compose(
            &result_2,
            &u_move.puzzle_state,
            &cube3_def.sorted_orbit_defs,
        );
        assert_eq!(
            exact_corners_pruning_table.hash_orbit_state(&result_1),
            67775130
        );
        result_2.replace_compose(
            &result_1,
            &u_move.puzzle_state,
            &cube3_def.sorted_orbit_defs,
        );
        assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_2), 0);

        // shortest 11 cycle alg
        result_1 = apply_moves(&cube3_def, &solved, "U R U F L R' U' R' F' D'", 1);

        assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);
        result_2.replace_compose(
            &result_1,
            &u_move.puzzle_state,
            &cube3_def.sorted_orbit_defs,
        );
        assert_eq!(
            exact_corners_pruning_table.hash_orbit_state(&result_2),
            24476904
        );
        result_1.replace_compose(
            &result_2,
            &u_move.puzzle_state,
            &cube3_def.sorted_orbit_defs,
        );
        assert_eq!(
            exact_corners_pruning_table.hash_orbit_state(&result_1),
            57868020
        );
        result_2.replace_compose(
            &result_1,
            &u_move.puzzle_state,
            &cube3_def.sorted_orbit_defs,
        );
        assert_eq!(
            exact_corners_pruning_table.hash_orbit_state(&result_2),
            67775130
        );
        result_1.replace_compose(
            &result_2,
            &u_move.puzzle_state,
            &cube3_def.sorted_orbit_defs,
        );
        assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);

        assert_ne!(solved, result_1);
    }

    #[test]
    fn test_exact_orbit_hasher_is_exact() {}
}
