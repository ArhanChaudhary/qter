//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use super::puzzle::PuzzleState;

pub trait PruningTable<P: PuzzleState> {
    fn insert(&mut self, puzzle_state: &P, depth: u8);
    fn commit_depth_traversed(&mut self, depth: u8);
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

pub struct ApproximatePruningTable<P: PuzzleState> {
    // u8::MAX means unvisited
    table: Box<[u8]>,
    depth_traversed: u8,
    _marker: std::marker::PhantomData<P>,
}

impl<P: PuzzleState> ApproximatePruningTable<P> {
    pub fn new(entries: usize) -> ApproximatePruningTable<P> {
        ApproximatePruningTable {
            table: vec![u8::MAX; entries].into_boxed_slice(),
            depth_traversed: 0,
            _marker: std::marker::PhantomData,
        }
    }

    fn hash_to_index(&self, hash: u64) -> usize {
        (hash % (self.table.len() as u64)) as usize
    }
}

impl<P: PuzzleState> PruningTable<P> for ApproximatePruningTable<P> {
    fn insert(&mut self, puzzle_state: &P, depth: u8) {
        assert!(depth < u8::MAX);

        let entry = &mut self.table[self.hash_to_index(fxhash::hash64(puzzle_state))];
        *entry = (*entry).min(depth);
    }

    fn commit_depth_traversed(&mut self, depth: u8) {
        assert!(self.depth_traversed <= depth);
        self.depth_traversed = depth;
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        match self.table[self.hash_to_index(fxhash::hash64(puzzle_state))] {
            u8::MAX => self.depth_traversed,
            v => v,
        }
    }
}

pub struct ZeroTable;

impl<P: PuzzleState> PruningTable<P> for ZeroTable {
    fn insert(&mut self, _puzzle_state: &P, _depth: u8) {}

    fn commit_depth_traversed(&mut self, _depth: u8) {}

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}
