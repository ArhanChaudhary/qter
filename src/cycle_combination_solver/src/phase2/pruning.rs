//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use super::puzzle::{PuzzleDef, PuzzleState};

// Trait declarations

pub trait PruningTables<'a, P: PuzzleState + 'a> {
    type GenerateMeta;

    fn generate(generate_meta: Self::GenerateMeta) -> Self;
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

/// A trait for a pruning table storage backend
pub trait StorageBackend<const EXACT: bool> {
    fn new_with_entries(max_entries: u64) -> Self;
    fn permissible_heuristic_hash(&self, hash: u64) -> u8;
    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic);
    fn commit_depth_traversed(&mut self, depth_traversed: u8);
}

/// A trait for a pruning table acting on a single orbit.
trait OrbitPruningTable<P: PuzzleState> {
    fn generate(puzzle_def: &PuzzleDef<P>, orbit_index: usize, max_size_bytes: u64) -> (Self, u64)
    where
        Self: Sized;

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64;

    /// Implementors are expected to forward the call to their storage backend.
    /// Interestingly, the alternative way of requiring a storage backend getter
    /// needs a trait object which is slow so this seems to be the best way.
    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8;

    /// This convenience function is a performance optimization that avoids two
    /// otherwise dynamic dispatches.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.permissible_heuristic_hash_outer(self.hash_puzzle_state(puzzle_state))
    }
}

// Data structure declarations

struct OrbitPruningTables<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    orbit_pruning_tables: Box<[Box<dyn OrbitPruningTable<P>>]>,
}

pub struct OrbitPruningTablesGenerateMeta<'a, P: PuzzleState> {
    puzzle_def: &'a PuzzleDef<P>,
    max_size_bytes: u64,
    // field to force specific tables (for tests)?
}

pub struct UncompressedStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    depth_traversed: u8,
}

struct TANSStorageEncodingTable {
    // silly things here
}

pub struct TANSStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    counts_by_depth: Box<[u64]>,
    encoding_tables: Box<[TANSStorageEncodingTable]>,
}

/// This type isn't actually entirely useless; I will use it for tables that
/// have no remaining allocable space (by the max_size_bytes option).
pub struct ZeroStorageBackend;

pub struct ApproximatePruningTable<'a, P: PuzzleState, S: StorageBackend<false>> {
    storage_backend: S,
    puzzle_def: &'a PuzzleDef<P>,
    orbit_index: usize,
}

pub struct ExactPruningTable<'a, P: PuzzleState, S: StorageBackend<true>> {
    storage_backend: S,
    puzzle_def: &'a PuzzleDef<P>,
    orbit_index: usize,
}

pub struct CycleTypePruningTable<'a, P: PuzzleState, S: StorageBackend<true>> {
    storage_backend: S,
    puzzle_def: &'a PuzzleDef<P>,
    orbit_index: usize,
}

pub struct ZeroTable<P: PuzzleState>(std::marker::PhantomData<P>);

// Implementations

use private::OrbitPruneHeuristic;
mod private {
    #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
    #[repr(transparent)]
    pub struct OrbitPruneHeuristic(u8);

    impl OrbitPruneHeuristic {
        const VACANT: u8 = u8::MAX;

        pub fn vacant() -> OrbitPruneHeuristic {
            OrbitPruneHeuristic(Self::VACANT)
        }

        pub fn occupied(depth_traversed: u8) -> Option<OrbitPruneHeuristic> {
            if depth_traversed == Self::VACANT {
                None
            } else {
                Some(OrbitPruneHeuristic(depth_traversed))
            }
        }

        pub fn is_vacant(&self) -> bool {
            self.0 == Self::VACANT
        }

        pub fn get_occupied(&self) -> Option<u8> {
            if self.is_vacant() { None } else { Some(self.0) }
        }
    }
}

impl<'a, P: PuzzleState> PruningTables<'a, P> for OrbitPruningTables<'a, P> {
    type GenerateMeta = OrbitPruningTablesGenerateMeta<'a, P>;

    fn generate(generate_meta: OrbitPruningTablesGenerateMeta<P>) -> OrbitPruningTables<P> {
        let mut orbit_pruning_tables = vec![];
        let mut remaining_size = generate_meta.max_size_bytes;
        // Already sorted by (piece count, orientation) which is (usually) from
        // smallest to largest which makes this work. This essentially populates
        // the smallest pruning tables while dynamically updating how much space
        // is reserved for the remaining orbit tables.
        for orbit_index in 0..generate_meta.puzzle_def.sorted_orbit_defs.len() {
            let unprocessed_orbits_count =
                generate_meta.puzzle_def.sorted_orbit_defs.len() - orbit_index;
            let (orbit_pruning_table, used_size) = choose_pruning_table(
                generate_meta.puzzle_def,
                orbit_index,
                remaining_size / unprocessed_orbits_count as u64,
            );
            remaining_size -= used_size;
            orbit_pruning_tables.push(orbit_pruning_table);
        }

        OrbitPruningTables {
            puzzle_def: generate_meta.puzzle_def,
            orbit_pruning_tables: orbit_pruning_tables.into_boxed_slice(),
        }
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.orbit_pruning_tables
            .iter()
            .fold(0, |best_bound, orbit_pruning_table| {
                best_bound.max(orbit_pruning_table.permissible_heuristic(puzzle_state))
            })
    }
}

/// Choose the appropriate pruning table based on the orbit definition and size.
/// Returns a pruning table trait object along with its size in bytes.
fn choose_pruning_table<P: PuzzleState>(
    puzzle_def: &PuzzleDef<P>,
    orbit_index: usize,
    max_size_bytes: u64,
) -> (Box<dyn OrbitPruningTable<P>>, u64) {
    macro_rules! table {
        ($a:ident, $b:ident) => {{
            let (table, used_size) = $a::<$b>::generate(puzzle_def, orbit_index, max_size_bytes);
            (Box::new(table), used_size)
        }};
    }

    // table!(ExactPruningTable, ZeroStorageBackend)
    todo!()
}

impl<const EXACT: bool> StorageBackend<EXACT> for UncompressedStorageBackend<EXACT> {
    fn new_with_entries(max_entries: u64) -> Self {
        let data = vec![OrbitPruneHeuristic::vacant(); max_entries as usize].into_boxed_slice();
        UncompressedStorageBackend {
            data,
            depth_traversed: 0,
        }
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        self.data[hash as usize]
            .get_occupied()
            .unwrap_or(self.depth_traversed)
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            self.data[hash as usize] = orbit_prune_heuristic;
        } else {
            self.data[hash as usize] = self.data[hash as usize].min(orbit_prune_heuristic);
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        self.depth_traversed = depth_traversed;
    }
}

impl<const EXACT: bool> StorageBackend<EXACT> for TANSStorageBackend<EXACT> {
    fn new_with_entries(max_entries: u64) -> Self {
        todo!();
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        todo!();
    }
}

impl StorageBackend<true> for ZeroStorageBackend {
    fn new_with_entries(max_entries: u64) -> Self {
        ZeroStorageBackend
    }

    fn permissible_heuristic_hash(&self, _hash: u64) -> u8 {
        0
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {}

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {}
}

impl<'a, P: PuzzleState, S: StorageBackend<false>> OrbitPruningTable<P>
    for ApproximatePruningTable<'a, P, S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size_bytes: u64,
    ) -> (ApproximatePruningTable<'a, P, S>, u64) {
        todo!();
    }

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64 {
        fxhash::hash64(
            &puzzle_state
                .orbit_bytes_by_index(self.orbit_index, &self.puzzle_def.sorted_orbit_defs),
        )
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<'a, P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<P>
    for ExactPruningTable<'a, P, S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size_bytes: u64,
    ) -> (ExactPruningTable<'a, P, S>, u64) {
        todo!();
    }

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64 {
        todo!();
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<'a, P: PuzzleState, S: StorageBackend<true>> OrbitPruningTable<P>
    for CycleTypePruningTable<'a, P, S>
{
    fn generate(
        puzzle_def: &PuzzleDef<P>,
        orbit_index: usize,
        max_size_bytes: u64,
    ) -> (CycleTypePruningTable<'a, P, S>, u64) {
        todo!();
    }

    fn hash_puzzle_state(&self, puzzle_state: &P) -> u64 {
        todo!();
    }

    fn permissible_heuristic_hash_outer(&self, hash: u64) -> u8 {
        self.storage_backend.permissible_heuristic_hash(hash)
    }
}

impl<'a, P: PuzzleState + 'a> PruningTables<'a, P> for ZeroTable<P> {
    type GenerateMeta = ();

    fn generate(_generate_meta: ()) -> Self {
        ZeroTable(std::marker::PhantomData)
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::phase2::puzzle::{cube3::Cube3, random_3x3_state};
    use puzzle_geometry::ksolve::KPUZZLE_3X3;

    #[test]
    fn test_orbit_prune_heuristic_invariants() {
        let vacant = OrbitPruneHeuristic::vacant();
        assert!(vacant.is_vacant());
        assert_eq!(vacant.get_occupied(), None);

        let occupied = OrbitPruneHeuristic::occupied(5).unwrap();
        assert!(!occupied.is_vacant());
        assert_eq!(occupied.get_occupied(), Some(5));

        let occupied = OrbitPruneHeuristic::occupied(255);
        assert!(occupied.is_none());
    }

    #[test]
    fn test_exact_uncompressed_storage_backend() {
        let mut storage = UncompressedStorageBackend::<true>::new_with_entries(100);

        storage.set_heuristic_hash(5, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(5), 3);

        assert_eq!(storage.permissible_heuristic_hash(6), 0);
        storage.commit_depth_traversed(4);
        assert_eq!(storage.permissible_heuristic_hash(6), 4);
        assert_eq!(storage.permissible_heuristic_hash(5), 3);
    }

    #[test]
    fn test_approximate_uncompressed_storage_backend() {
        let mut storage = UncompressedStorageBackend::<false>::new_with_entries(100);

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 3);

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(2).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 2);
    }

    #[test]
    fn test_zero_storage_backend_gives_zero() {
        let storage = ZeroStorageBackend;
        assert_eq!(storage.permissible_heuristic_hash(0), 0);
        assert_eq!(storage.permissible_heuristic_hash(1), 0);
        assert_eq!(storage.permissible_heuristic_hash(2), 0);
    }

    #[test]
    fn test_zero_table() {
        let cube3_def: PuzzleDef<Cube3> = (&*KPUZZLE_3X3).try_into().unwrap();
        let zero_table = ZeroTable::generate(());

        let random_state = random_3x3_state(&cube3_def, &cube3_def.new_solved_state());
        assert_eq!(zero_table.permissible_heuristic(&random_state), 0);
    }
}
