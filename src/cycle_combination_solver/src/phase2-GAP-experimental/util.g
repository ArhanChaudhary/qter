top_face := [1..8];
bottom_face := [41..48];
facelet_to_speffz := "aabdbdcceefhfhggiijljlkkmmnpnpooqqrtrtssuuvxvxww";

PermutationSpeffz := function(perm)
  local cycles, edge_cycles, corner_cycles, ret, corners_or_edges, buf, i,
    cycle, cycle_facelet, visited_facelets, buf_pos, orient_facelet_index,
    corners_then_edges, before_orient_facelet_index, starting_cubie;
  cycles := Cycles(perm, MovedPoints(perm));
  edge_cycles := Filtered(cycles, c -> ForAny(c, f -> f in edge_facelets));
  corner_cycles := Filtered(cycles, c -> ForAny(c, f -> f in corner_facelets));
  ret := "";
  for corners_then_edges in [1..2] do
    if corners_then_edges = 1 then
      corners_or_edges := corner_cubies;
      cycles := corner_cycles;
      buf := corner_facelet_buf;
    else
      Add(ret, '.');
      corners_or_edges := edge_cubies;
      cycles := edge_cycles;
      buf := edge_facelet_buf;
    fi;
    cycle := First(cycles, c -> buf in c);
    if cycle = fail then
      visited_facelets := [];
    else
      buf_pos := PositionProperty(cycle, c -> c = buf);
      visited_facelets := ShallowCopy(First(
        corners_or_edges,
        c -> buf in c
      ));
      i := 1;
      while true do
        cycle_facelet := cycle[
          (buf_pos + i - 1) mod Length(cycle) + 1
        ];
        if cycle_facelet in visited_facelets then
          break;
        fi;
        Add(ret, facelet_to_speffz[cycle_facelet]);
        i := i + 1;
      od;
    fi;
    for cycle in cycles do
      if ForAny(cycle, c -> Position(visited_facelets, c) <> fail) then
        continue;
      fi;
      starting_cubie := ShallowCopy(First(
        corners_or_edges,
        c -> cycle[1] in c
      ));
      if ForAny(corners_or_edges, c -> IsEqualSet(c, cycle)) then
        if corners_then_edges = 1 then
          orient_facelet_index := PositionProperty(cycle,
            c -> c in top_face or c in bottom_face
          );
          before_orient_facelet_index := (
            orient_facelet_index - 2
          ) mod 3 + 1;
        else
          before_orient_facelet_index := 1;
        fi;
        Add(ret, UppercaseChar(facelet_to_speffz[cycle[
          before_orient_facelet_index
        ]]));
      else
        Add(ret, facelet_to_speffz[cycle[1]]);
        i := 2;
        while true do
          cycle_facelet := cycle[(i - 1) mod Length(cycle) + 1];
          Add(ret, facelet_to_speffz[cycle_facelet]);
          if cycle_facelet in starting_cubie then
            break;
          fi;
          i := i + 1;
        od;
      fi;
      Append(visited_facelets, starting_cubie);
    od;
  od;
  return ret;
end;


LiftClassesEANonsolvCentralOfOrder := function( Npcgs, cl,hom,pcisom,solvtriv, order )
local  classes,            # classes to be constructed, the result
        field,             # field over which <Npcgs> is a vector space
        o,
        n,##r,               # dimensions
        space,
        com,
        comms,
        ##mats,
        ##decomp,
        gens,
        ##radidx,
        ##stabrad,stabfacgens,stabfacimg,stabrsubsz,relo,orblock,fe,st,
        stabrad,stabfacgens,
        ##orb,rep,reps,repword,repwords,p,stabfac,img,vp,genum,gpsz,
        ##subsz,solvsz,i,j,
        v,
        h,              # preimage `cl.representative' under <hom>
        w,              # coefficient vectors for projection along $[h,N]$
        c;              # loop variable

  field := GF( RelativeOrders( Npcgs )[ 1 ] );
  h := cl[1];
  #reduce:=ReducedPermdegree(C);
  #if reduce<>fail then
  #  C:=Image(reduce,C);
  #  Info(InfoHomClass,4,"reduced to deg:",NrMovedPoints(C));
  #  h:=Image(reduce,h);
  #  N:=ModuloPcgs(SubgroupNC(C,Image(reduce,NumeratorOfModuloPcgs(N))),
#                 SubgroupNC(C,Image(reduce,DenominatorOfModuloPcgs(N))));
#  fi;

  # centrality still means that conjugation by c is multiplication with
  # [h,c] and that the complement space is generated by commutators [h,c]
  # for a generating set {c|...} of C.

  n:=Length(Npcgs);
  o:=One(field);
  stabrad:=Concatenation(cl[2],Npcgs);
  ##radidx:=Length(stabrad);
  stabfacgens:=cl[3];
  ##stabfacimg:=cl[4];
  ##gpsz:=cl[5];
  ##subsz:=gpsz;
  ##solvsz:=cl[6];
  ##stabfac:=TrivialSubgroup(Image(hom));

  gens:=Concatenation(stabrad,stabfacgens); # all generators
  # commutator space basis

  comms:=List(gens,c->o*ExponentsOfPcElement(Npcgs,Comm(h,c)));
  List(comms,x->ConvertToVectorRep(x,field));
  space:=List(comms,ShallowCopy);
  TriangulizeMat(space);
  space:=Filtered(space,i->i<>Zero(i)); # remove spurious columns

  com:=BaseSteinitzVectors(IdentityMat(n,field),space);

  # decomposition of vectors into the subspace basis
  ## r:=Length(com.subspace);
  ## if r>0 then
  ##   # if the subspace is trivial, everything stabilizes

  ##   decomp:=Concatenation(com.subspace,com.factorspace)^-1;
  ##   decomp:=decomp{[1..Length(decomp)]}{[1..r]};
  ##   decomp:=ImmutableMatrix(field,decomp);

  ##   # build matrices for the affine action
  ##   mats:=[];
  ##   for w in comms do
  ##     c:=IdentityMat(r+1,o);
  ##     c[r+1]{[1..r]}:=w*decomp; # translation bit
  ##     c:=ImmutableMatrix(field,c);
  ##     Add(mats,c);
  ##   od;

  ##   #subspace affine enumerator
  ##   v:=ExtendedVectors(field^r);

  ##   # orbit-stabilizer algorithm solv/nonsolv version
  ##   #C := Stabilizer( C, v, v[1],GeneratorsOfGroup(C), mats,OnPoints );

  ##   # assume small domain -- so no bother with bitlist
  ##   orb:= [v[1]];
  ##   reps:=[One(gens[1])];
  ##   repwords:=[[]];
  ##   stabrad:=[];
  ##   stabrsubsz:=Size(solvtriv);

  ##   vp:=1;

  ##   for genum in [radidx,radidx-1..1] do
  ##     relo:=RelativeOrders(pcisom!.sourcePcgs)[
  ##             DepthOfPcElement(pcisom!.sourcePcgs,gens[genum])];
  ##     img:=orb[1]*mats[genum];
  ##     repword:=repwords[vp];
  ##     p:=Position(orb,img);
  ##     if p=fail then
  ##       for j in [1..Length(orb)*(relo-1)] do
  ##         img:=orb[j]*mats[genum];
  ##         Add(orb,img);
  ##         Add(reps,reps[j]*gens[genum]);
  ##         Add(repwords,repword);
  ##       od;
  ##     else
  ##       rep:=gens[genum]/reps[p];
  ##       Add(stabrad,rep);
  ##       stabrsubsz:=stabrsubsz*relo;
  ##     fi;

  ##   od;
  ##   stabrad:=Reversed(stabrad);

  ##   Assert(1,solvsz=stabrsubsz*Length(orb));

  ##   #nosolvable part
  ##   orblock:=Length(orb);
  ##   vp:=1;
  ##   stabfacgens:=[];
  ##   stabfacimg:=[];
  ##   while vp<=Length(orb) do
  ##     for genum in [radidx+1..Length(gens)] do
  ##       img:=orb[vp]*mats[genum];
  ##       rep:=reps[vp]*gens[genum];
  ##       repword:=Concatenation(repwords[vp],[genum-radidx]);
  ##       p:=Position(orb,img);
  ##       if p=fail then
  ##         Add(orb,img);
  ##         Add(reps,rep);
  ##         Add(repwords,repword);
  ##         for j in [1..orblock-1] do
  ##           img:=orb[vp+j]*mats[genum];
  ##   #if img in orb then Error("HUH");fi;
  ##           Add(orb,img);
  ##           Add(reps,reps[vp+j]*gens[genum]);
  ##           # repword stays the same!
  ##           Add(repwords,repword);
  ##         od;
  ##       else
  ##         st:=rep/reps[p];
  ##         if Length(repword)>0 then
  ##           # build the factor group element
  ##           fe:=One(Image(hom));
  ##           for i in repword do
  ##             fe:=fe*cl[4][i];
  ##           od;
  ##           for i in Reversed(repwords[p]) do
  ##             fe:=fe/cl[4][i];
  ##           od;
  ##           if not fe in stabfac then
  ##             # not known -- add to generators
  ##             Add(stabfacgens,st);
  ##             Add(stabfacimg,fe);
  ##             stabfac:=ClosureGroup(stabfac,fe);
  ##           fi;
  ##         fi;
  ##       fi;
  ##     od;
  ##     vp:=vp+orblock;
  ##   od;

  ##   subsz:=stabrsubsz*Size(stabfac);
  ## else
  ##   stabrsubsz:=solvsz;
  ## fi;

  if Length(com.factorspace)=0 then
    ## classes :=[[h,stabrad,stabfacgens,stabfacimg,subsz,stabrsubsz]];
    if Order(h) = order then
      classes := [h];
    else
      classes := [];
    fi;
  else
    classes:=[];
    # enumerator of complement
    v:=field^Length(com.factorspace);
    for w in v do
      ## c := [h * PcElementByExponentsNC( Npcgs,w*com.factorspace),
      ##       stabrad,stabfacgens,stabfacimg,subsz,stabrsubsz];
      c := h * PcElementByExponentsNC( Npcgs,w*com.factorspace);
      #if reduce<>fail then
  #        Add(classes,[PreImagesRepresentative(reduce,c[1]),
  #          PreImage(reduce,c[2])]);
  #      else

  ##Assert(3,c[6]
  ##  =Size(Group(Concatenation(c[2],DenominatorOfModuloPcgs(Npcgs)))));

      if Order(c) = order then
        Add(classes,c);
      fi;
    od;
  fi;

#  Assert(1,ForAll(classes,i->i[1] in H and IsSubset(H,i[2])));
  return classes;
end;


LiftClassesEATrivRepOfOrder := function( Npcgs, cl, fants,hom, pcisom,solvtriv, order)
    local  h,field,one,gens,imgs,M,bas,
           c,i,npcgsact,usent,dim,found,nsgens,nsimgs,mo,
           pcgsimgs,
           ##sel,pcgs,fasize,nsfgens,fgens,a,norb,fstab,rep,reps,frep,freps,
           sel,pcgs,fasize,nsfgens,fgens,a,norb,fstab,frep,freps,
           ## orb,p,rsgens,el,img,j,basinv,newo,orbslev,ssd,result,o,subs,orbsub,
           orb,p,el,img,j,basinv,newo,orbslev,ssd,result,o,subs,orbsub,
           ## sgens,sfgens,z,minvecs,orpo,norpo,maxorb,
           sfgens,z,minvecs,orpo,norpo,maxorb,
           IteratedMinimizer,OrbitMinimizer,Minimizer,miss;

  npcgsact:=function(c)
    local M,i;
    M := [  ];
    for i  in [ 1 .. dim ]  do
        M[ i ] := ExponentsConjugateLayer( Npcgs,
        Npcgs[ i ] , c )*one;
    od;
    M:=ImmutableMatrix(field,M);
    return M;
  end;

  pcgs:=MappingGeneratorsImages(pcisom)[1];
  field:=GF(RelativeOrders(Npcgs)[1]);
  one:=One(field);
  dim:=Length(Npcgs);

  # action of group
  h := cl[1];
  gens:=Concatenation(cl[2],Npcgs,cl[3]); # all generators
  fgens:=Concatenation(ListWithIdenticalEntries(
            Length(Npcgs)+Length(cl[2]),One(Range(hom))),cl[4]);
  imgs := [  ];
  for c  in gens  do
    Add( imgs, npcgsact(c));
  od;
  sel:=Filtered([1..Length(imgs)],x->Order(imgs[x])>1);

  usent:=0;
  found:=0;
  while usent<Length(fants) do
    usent:=usent+1;
    nsfgens:=NormalIntersection(fants[usent],Group(cl[4]));
    fasize:=Size(nsfgens);
    nsfgens:=SmallGeneratingSet(nsfgens);
    nsgens:=List(nsfgens,x->PreImagesRepresentative(hom,x));
    nsimgs:=List(Concatenation(pcgs,nsgens),npcgsact);
    mo:=GModuleByMats(nsimgs,field);
    if not MTX.IsIrreducible(mo) then
      # split space as direct sum under normal sub -- clifford Theory
      o:=MTX.BasesMinimalSubmodules(mo);
      if Length(o)>50 then
        o:=o{Set([1..50],x->Random(1,Length(o)))};
      fi;

      for i in Filtered([1..Length(o)],
          x->(mo.dimension mod Length(o[x])=0) and Length(o[x])>found) do
        # subspace and images as orbit
        bas:=o[i];
        ssd:=Length(bas);
        if found<ssd and Size(field)^ssd<3*10^7 then
          Info(InfoHomClass,2,"Trying subspace ",ssd," in ",mo.dimension);
          orbsub:=Orbit(Group(imgs{sel}),bas,OnSubspacesByCanonicalBasis);
          if Length(orbsub)*Length(bas)<>Length(bas[1]) then
            subs:=MTX.InducedActionSubmodule(mo,bas);
            subs:=MTX.Homomorphisms(subs,mo);
            orbsub:=Filtered(subs,x->x in orbsub);
          fi;
          if Length(orbsub)*Length(bas)=Length(bas[1]) and
              RankMat(Concatenation(orbsub))=Length(bas[1]) then
            found:=ssd;
            el:=[orbsub,bas,fasize,nsgens,nsimgs,nsfgens,mo];

            subs:=List([1..Length(orbsub)],x->[(x-1)*ssd+1..x*ssd]);
            bas:=ImmutableMatrix(field,Concatenation(orbsub)); # this is the new basis
            basinv:=bas^-1;
              Assert(1,basinv<>fail);
          else
            Info(InfoHomClass,3,"failed ",Length(orbsub));
          fi;
        fi;
      od;
    fi;

  od;

  if found=0 then
    Info(InfoHomClass,3,"basic case");
    #Error("BASIC");
    return fail;
  else
    ssd:=found;
    #el is [orbsub,bas,fasize,nsgens,nsimgs,nsfgens,mo];
    orbsub:=el[1];
    bas:=el[2];
    fasize:=el[3];
    nsgens:=el[4];
    nsimgs:=el[5];
    nsfgens:=el[6];
    mo:=el[7];
    Info(InfoHomClass,2,"Using subspace ",ssd," in ",mo.dimension);

    subs:=List([1..Length(orbsub)],x->[(x-1)*ssd+1..x*ssd]);
    bas:=ImmutableMatrix(field,Concatenation(orbsub)); # this is the new basis
    basinv:=bas^-1;
    Assert(1,basinv<>fail);

  fi;

  imgs:=List(imgs,x->bas*x*basinv); # write wrt new basis

  # now determine N-orbits, stepwise

  solvtriv:=Subgroup(Range(pcisom),
      List(DenominatorOfModuloPcgs(Npcgs),x->ImagesRepresentative(pcisom,x)));

  orb:=[rec(len:=1,rep:=Zero(bas[1]),
        stabfacgens:=nsgens,
        stabfacimgs:=nsfgens,
        # only generators in factor
        stabradgens:=Filtered(pcgs,x->not x in DenominatorOfModuloPcgs(Npcgs)),
        stabrsubsz:=Size(Image(pcisom)),
        subsz:=fasize*Product(RelativeOrders(pcgs))
                   )];

  orbslev:=[];
  maxorb:=1;
  for i in [1..Length(subs)] do
    norb:=[];
    el:=Elements(VectorSpace(field,IdentityMat(Length(bas),field){subs[i]}));
    for o in orb do
      newo:= OrbitsRepsAndStabsVectorsMultistage(
             o.stabradgens,List(o.stabradgens,x->bas*npcgsact(x)*basinv),
             pcisom,o.stabrsubsz,solvtriv,
             o.stabfacgens,List(o.stabfacgens,x->bas*npcgsact(x)*basinv),
             o.stabfacimgs,hom,o.subsz,OnRight,
             el);
      for j in newo do
        if j.len>maxorb then maxorb:=j.len;fi;
        if i>1 then
          j.len:=j.len*o.len;
          j.rep:=Concatenation(o.rep{[1..(i-1)*ssd]},j.rep{[(i-1)*ssd+1..Length(j.rep)]});
          MakeImmutable(j.rep);
        fi;
        Add(norb,j);
      od;
    od;
    Info(InfoHomClass,3,"Level ",i," , ",Length(norb)," orbits");
    orb:=norb;
    Add(orbslev,ShallowCopy(orb));
  od;

  IteratedMinimizer:=function(vec,allcands)
  local i,a,cands,mapper,fmapper,stabfacgens,stabradgens,stabfacimgs,
        range,lcands,lvec;
    cands:=allcands;
    mapper:=One(Source(hom));
    fmapper:=One(Range(hom));
    stabfacgens:=nsgens;
    stabfacimgs:=nsfgens;
    stabradgens:=pcgs;
    for i in [1..Length(subs)] do
      range:=[1..i*ssd];
      lcands:=Filtered(orbslev[i],
        x->ForAny(cands,y->y.rep{range}=x.rep{range}));
      lvec:=Concatenation(vec{range},Zero(vec{[i*ssd+1..Length(vec)]}));
      result:=OrbitMinimumMultistage(stabradgens,
           List(stabradgens,x->bas*npcgsact(x)*basinv),
           stabfacgens,
           List(stabfacgens,x->bas*npcgsact(x)*basinv),
           stabfacimgs,
           OnRight,lvec,maxorb,#Maximum(List(lcands,x->x.len)),
           Set(lcands,x->x.rep));
      a:=First(lcands,x->x.rep{range}=result.min{range});
      mapper:=mapper*result.elm;
      fmapper:=fmapper*result.felm;
      vec:=vec*bas*npcgsact(result.elm)*basinv; # map vector to so far canonical
      # not all classes are feasible
      Assert(1,ForAny(cands,x->x.rep{range}=vec{range}));
      cands:=Filtered(cands,x->x.rep{range}=vec{range});
      stabradgens:=a.stabradgens;
      stabfacgens:=a.stabfacgens;
      stabfacimgs:=a.stabfacimgs;
    od;
    if Length(cands)<>1 then Error("nonunique");fi;
    return rec(elm:=mapper,felm:=fmapper,min:=vec,nclass:=cands[1]);
  end;

  pcgsimgs:=List(pcgs,x->bas*npcgsact(x)*basinv);
  nsimgs:=List(nsgens,x->bas*npcgsact(x)*basinv);


  OrbitMinimizer:=function(vec,allcands)
  local a;

  if false and allcands[1].len>1 then
    Error();
  fi;
    a:=OrbitMinimumMultistage(pcgs,pcgsimgs,
        nsgens,nsimgs,nsfgens,
        OnRight,vec,allcands[1].len,minvecs);
    a.nclass:=First(allcands,x->x.rep=a.min);
    return a;

  end;

  orpo:=NewDictionary(orb[Length(orb)].rep,true,field^Length(orb[1].rep));
  for p in [1..Length(orb)] do
    AddDictionary(orpo,orb[p].rep,p);
  od;

  # now do an orbit algorithm on orb. As the orbit is short no need for
  # two-step.

  newo:=[];
  while Length(orb)>0 do
    # pick new one
    p:=First([1..Length(orb)],x->IsBound(orb[x]));
    norb:=[orb[p]];
    norpo:=[];
    norpo[p]:=1;
    el:=Filtered(orb,x->x.len=orb[p].len);
    minvecs:=Set(el,x->x.rep);
#el:=orbslev[3];
    if orb[p].len>30000 then
      Minimizer:=IteratedMinimizer;
    else
      Minimizer:=OrbitMinimizer;
    fi;

    # as Rad <=N we can assume that the radical part of the stabilizer
    # is known
    ## rsgens:=ShallowCopy(orb[p].stabradgens);
    a:=Difference([1..Length(gens)],sel);
    ## sgens:=Concatenation(orb[p].stabfacgens,gens{a});
    sfgens:=Concatenation(orb[p].stabfacimgs,fgens{a});
    fstab:=Group(sfgens);
    ## reps:=[One(Source(hom))];
    freps:=[One(Range(hom))];
    Unbind(orb[p]);

    # factor missing from stop
    miss:=cl[5]/(norb[1].len*Size(fstab)*norb[1].stabrsubsz);

    i:=1;
    while i<=Length(norb) and miss>1 do
      for j in sel do
        img:=OnRight(norb[i].rep,imgs[j]);
        img:=Minimizer(img,el);

        ##rep:=reps[i]*gens[j]*img.elm;
        frep:=freps[i]*fgens[j]*img.felm;
        p:=LookupDictionary(orpo,img.min);
        #p:=PositionProperty(norb,x->x.rep=img.min);
        if p=fail then
          return fail;
          Error("unknown minimum");
        elif IsBound(norpo[p]) then
          # old point
          p:=norpo[p];
          if miss>=2 then
            Assert(1,norb[i].rep*imgs[j]*bas*npcgsact(img.elm)*basinv=norb[p].rep);
    #Print("A",i," ",j," ",Length(el),"\n");
            # old point -- stabilize
            a:=frep/freps[p];
            if not a in sfgens then
              ##Add(sgens,rep/reps[p]);
              Add(sfgens,a);
              miss:=miss*Size(fstab);
              fstab:=ClosureGroup(fstab,a);
              miss:=miss/Size(fstab);
#Print("miss1:",EvalF(miss)," ",i," of ",Length(norb),"\n");

            fi;
          fi;
        else
  #Print("B",i," ",j," ",Length(el),"\n");
          # new point
          #p:=PositionProperty(orb,x->x.rep=img.min);
          Assert(1,norb[i].rep*imgs[j]*bas*npcgsact(img.elm)*basinv=orb[p].rep);
          Add(norb,orb[p]);
          norpo[p]:=Length(norb);
          ##Add(reps,rep);
          Add(freps,frep);
          miss:=miss*(Length(norb)-1)/Length(norb);
#Print("miss3:",EvalF(miss)," ",i," of ",Length(norb),"\n");
          # add conjugate stabilizer
          #Append(rsgens,List(orb[p].stabradgens,x->rep*x/rep));
          for z in [1..Length(orb[p].stabfacgens)] do
            a:=frep*orb[p].stabfacimgs[z]/frep;
            if not a in fstab then
              ##Add(sgens,rep*orb[p].stabfacgens[z]/rep);
              Add(sfgens,a);
              miss:=miss*Size(fstab);
              fstab:=ClosureGroup(fstab,a);
              miss:=miss/Size(fstab);
#Print("miss2:",miss,"\n");
            fi;
          od;
          Unbind(orb[p]);
        fi;
      od;
      i:=i+1;
    od;
if miss<>1 then
  # something is dodgy -- fallback to the default algorithm
  return fail;Error("HEH?");fi;
    Info(InfoHomClass,3,"Fused ",Length(norb),"*",norb[1].len," ",
      Number(orb)," left");
    ## Assert(1,ForAll(rsgens,x->norb[1].rep*bas*npcgsact(x)*basinv=norb[1].rep));
    ## Assert(1,ForAll(sgens,x->norb[1].rep*bas*npcgsact(x)*basinv=norb[1].rep));
#if ForAny(rsgens,x->Order(x)=1) then Error("HUH5"); fi;

    ## a:=[h*PcElementByExponents(Npcgs,norb[1].rep*bas),rsgens,sgens,sfgens,
    ##     cl[5]/Length(norb)/norb[1].len, norb[1].stabrsubsz];
    a := h*PcElementByExponents(Npcgs,norb[1].rep*bas);

#rsgens:=List(rsgens,x->ImageElm(pcisom,x));
#if rsgens<>InducedPcgsByGenerators(FamilyPcgs(Range(pcisom)),rsgens) then
#  Error("nonpcgs!");
#fi;
    if Order(a) = order then
      Add(newo,a);
    fi;
  od;
  return newo;
end;


LiftClassesEANonsolvGeneralOfOrder := function(Npcgs, cl, hom, pcisom,solvtriv, order)
    local  classes,    # classes to be constructed, the result
           correctingelement,
           field,      # field over which <N> is a vector space
           one,
           h,          # preimage `cl.representative' under <hom>
           cg,
           cNh,        # centralizer of <h> in <N>
           gens,   # preimage `Centralizer( cl )' under <hom>
           r,          # dimension of <N>
           ran,        # constant range `[ 1 .. r ]'
           aff,        # <N> as affine space
           imgs,  M,   # generating matrices for affine operation
           orb,        # orbit of affine operation
           rep,# set of classes with canonical representatives
           c,  i, # loop variables
           ##PPcgs,denomdepths,
           ##correctionfactor,
           ##stabfacgens,
           ##stabfacimg,
           ##stabrad,
           gpsz,solvsz,##,
           b,
           fe,
           radidx,
           comm;# for class correction

##   correctingelement:=function(h,rep,fe)
##   local comm;
##     comm:=Comm( h, fe ) * Comm( rep, fe );
##     comm:= ExponentsOfPcElement(Npcgs,comm)*one;
##     ConvertToVectorRep(comm,field);
##     comm := List(comm * cg.inverse,Int);
##     comm:=PcElementByExponentsNC
##       ( Npcgs, Npcgs{ cg.needed }, -comm );
##     fe:=fe*comm;
##     return fe;
##   end;

  h := cl[1];

  field := GF( RelativeOrders( Npcgs )[ 1 ] );
  one:=One(field);
  ##PPcgs:=ParentPcgs(NumeratorOfModuloPcgs(Npcgs));
  ##denomdepths:=ShallowCopy(DenominatorOfModuloPcgs(Npcgs)!.depthsInParent);
  ##Add(denomdepths,Length(PPcgs)+1); # one

  # Determine the subspace $[h,N]$ and calculate the centralizer of <h>.
  #cNh := ExtendedPcgs( DenominatorOfModuloPcgs( N!.capH ),
  #               VSDecompCentAction( N, h, N!.capH ) );

  #oldcg:=KernelHcommaC(Npcgs,h,NumeratorOfModuloPcgs(Npcgs),2);

  #cg:=VSDecompCentAction( Npcgs, h, NumeratorOfModuloPcgs(Npcgs),field,2 );
  cg:=VSDecompCentAction( Npcgs, h, Npcgs,field,2 );
#Print("complen =",Length(cg.baseComplement)," of ",cg.dimensionN,"\n");
#if Length(Npcgs)>5 then Error("cb"); fi;

  cNh:=cg.cNh;

  r := Length( cg.baseComplement );
  ran := [ 1 .. r ];

  # Construct matrices for the affine operation on $N/[h,N]$.
  Info(InfoHomClass,4,"space=",Size(field),"^",r);

  gens:=Concatenation(cl[2],Npcgs,cl[3]); # all generators
  gpsz:=cl[5];

  solvsz:=cl[6];

  radidx:=Length(Npcgs)+Length(cl[2]);

  imgs := [  ];
  for c  in gens  do
    M := [  ];
    for i  in [ 1 .. r ]  do
        M[ i ] := Concatenation( ExponentsConjugateLayer( Npcgs,
              Npcgs[ cg.baseComplement[ i ] ] , c )
              * cg.projection, [ Zero( field ) ] );
    od;
    M[ r + 1 ] := Concatenation( ExponentsOfPcElement
                          ( Npcgs, Comm( h, c ) ) * cg.projection,
                          [ One( field ) ] );

    M:=ImmutableMatrix(field,M);
    Add( imgs, M );
  od;


  if Size(field)^r>3*10^8 then Error("too large");fi;
  aff := ExtendedVectors( field ^ r );

  # now compute orbits, being careful to get stabilizers in steps
  #orbreps:=[];
  #stabs:=[];

  orb:=OrbitsRepsAndStabsVectorsMultistage(gens{[1..radidx]},
        imgs{[1..radidx]},pcisom,solvsz,solvtriv,
        gens{[radidx+1..Length(gens)]},
        imgs{[radidx+1..Length(gens)]},cl[4],hom,gpsz,OnRight,aff);

  classes:=[];
  for b in orb do
    rep := PcElementByExponentsNC( Npcgs, Npcgs{ cg.baseComplement },
                    b.rep{ ran } );
##     #Assert(3,ForAll(GeneratorsOfGroup(stabsub),i->Comm(i,h*rep) in NT));
##     stabrad:=ShallowCopy(b.stabradgens);
## #Print("startdep=",List(stabrad,x->DepthOfPcElement(PPcgs,x)),"\n");
## #if ForAny(stabrad,x->Order(x)=1) then Error("HUH3"); fi;
##     stabfacgens:=b.stabfacgens;
##     stabfacimg:=b.stabfacimgs;

##     # correct generators. Partially in Pc Image
##     if Length(cg.needed)>0 then

##       stabrad:=List(stabrad,x->correctingelement(h,rep,x));
##       # must make proper pcgs -- correction does not preserve that
##       stabrad:=TFMakeInducedPcgsModulo(PPcgs,stabrad,denomdepths);

##       # we change by radical elements, so the images in the factor don't
##       # change
##       stabfacgens:=List(stabfacgens,x->correctingelement(h,rep,x));

##     fi;

##     correctionfactor:=Characteristic(field)^Length(cg.needed);
##     subsz:=b.subsz/correctionfactor;
##     c := [h * rep,stabrad,stabfacgens,stabfacimg,subsz,
##            b.stabrsubsz/correctionfactor];
##     Assert(3,Size(Group(Concatenation(DenominatorOfModuloPcgs(Npcgs),
##        stabrad,stabfacgens)))=subsz);

##     Add(classes,c);
    c := h * rep;
    if Order(c) = order then
      Add(classes,c);
    fi;
  od;

  return classes;

end;


ConjugacyClassesOfOrderViaRadical := function (G, order)
local ##r,        #radical
      f,        # G/r
      hom,      # G->f
      pcgs,mpcgs, #(modulo) pcgs
      pcisom,
      gens,
      ser,      # series
      radsize,len,ntrihom,
      mran,nran,
      central,
      fants,
      d,
      solvtriv,
      i,        #loop
      new,      # new classes
      cl,ncl;   # classes

  # it seems to be cleaner (and avoids deferring abelian factors) if we
  # factor out the radical first. (Note: The radical method for perm groups
  # stores the nat hom.!)
  ser:=FittingFreeLiftSetup(G);
  if Length(ser.pcgs)>0 then
    radsize:=Product(RelativeOrders(ser.pcgs));
  else
    radsize:=1;
  fi;
  len:=Length(ser.pcgs);

  if radsize=1 then
    hom:=ser.factorhom;
    if IsPermGroup(Range(hom)) and not IsPermGroup(Source(hom)) then
      f:=Image(hom,G);
      cl:=ConjugacyClassesFittingFreeGroup(f:onlysizes:=false);
      cl:=List(cl,x->[PreImagesRepresentative(hom,x[1]),
        PreImage(hom,x[2])]);
    else
      cl:=ConjugacyClassesFittingFreeGroup(G:onlysizes:=false);
    fi;
    ncl:=[];
    for i in cl do
      ##r:=ConjugacyClass(G,i[1],i[2]);
      ##Add(ncl,r);
      # Further optimization is possible, but ConjugacyClassesFittingFreeGroup
      # shall remain untouched
      Add(ncl, ConjugacyClass(G, i[1]));
    od;
    return ncl;
  fi;

  pcgs:=ser.pcgs;
  pcisom:=ser.pcisom;
  fants:=[];

  # store centralizers as rep, centralizer generators in radical,
  # centralizer generators with nontrivial
  # radfactor image, corresponding radfactor images
  # the generators in the radical do not list the generators of the
  # current layer after immediate lifting.

  if radsize=Size(G) then
    # solvable case
    hom:=ser.factorhom;
    d:=MappingGeneratorsImages(hom);
    mran:=Filtered([1..Length(d[2])],x->not IsOne(d[2][x]));
    cl:=[[One(G),[],d[1]{mran},d[2]{mran},Size(G),Size(G)]];
  else
    # nonsolvable
    if radsize>1 then
      hom:=ser.factorhom;
      ntrihom:=true;
      f:=Image(hom);
      # if lift setup is inherited, f might not be trivial-fitting
      if Size(SolvableRadical(f))>1 then
        # this is proper recursion
        cl:=ConjugacyClasses(f:onlysizes:=false);
        cl:=List(cl,x->[Representative(x),Centralizer(x)]);
      else
      # we need centralizers
        cl:=ConjugacyClassesFittingFreeGroup(f:onlysizes:=false);
      fi;
      fants:=Filtered(NormalSubgroups(f),x->Size(x)>1 and Size(x)<Size(f));
    else
      if IsPermGroup(G) then
        hom:=SmallerDegreePermutationRepresentation(G:cheap);
        ntrihom:=not IsOne(hom);;
      else
        hom:=IdentityMapping(G);
        ntrihom:=false;
      fi;
      f:=Image(hom);
      cl:=ConjugacyClassesFittingFreeGroup(f);
    fi;

    if ntrihom then
      ncl:=[];
      for i in cl do
        new:=[PreImagesRepresentative(hom,i[1])];
        if not IsInt(i[2]) then
          Add(new,[]); # no generators in radical yet
          gens:=SmallGeneratingSet(i[2]);
          Add(new,
            List(gens,x->PreImagesRepresentative(hom,x)));
          Add(new,gens);
          #TODO: PreImage groups?
          #Add(new,PreImage(hom,i[2]));
          Add(new,radsize*Size(i[2]));
          Add(new,radsize);
        fi;
        Add(ncl,new);
      od;
      cl:=ncl;

    fi;
  fi;

  Assert(3,ForAll(cl,x->x[6]=Size(Group(Concatenation(x[2],pcgs)))));

  for d in [2..Length(ser.depths)] do
    #M:=ser[i-1];
    #N:=ser[i];
    mran:=[ser.depths[d-1]..len];
    nran:=[ser.depths[d]..len];

    mpcgs:=InducedPcgsByPcSequenceNC(pcgs,pcgs{mran}) mod
           InducedPcgsByPcSequenceNC(pcgs,pcgs{nran});

    central:= ForAll(GeneratorsOfGroup(G),
                i->ForAll(mpcgs,
                  j->DepthOfPcElement(pcgs,Comm(i,j))>=ser.depths[d]));

    # abelian factor, use affine methods
    Info(InfoHomClass,1,"abelian factor ",d,": ",
      Product(RelativeOrders(ser.pcgs){mran}), "->",
      Product(RelativeOrders(ser.pcgs){nran})," central:",central);

    ncl:=[];
    solvtriv:=Subgroup(Range(pcisom),
        List(DenominatorOfModuloPcgs(mpcgs),x->ImagesRepresentative(pcisom,x)));
    for i in cl do
      #Assert(2,ForAll(GeneratorsOfGroup(i[2]),j->Comm(i[1],j) in M));
      if (central or ForAll(Concatenation(i[2],i[3]),
                i->ForAll(mpcgs,
                  j->DepthOfPcElement(pcgs,Comm(i,j))>=ser.depths[d])) ) then
        Info(InfoHomClass,3,"central step");
        ##new:=LiftClassesEANonsolvCentral(mpcgs,i,hom,pcisom,solvtriv);
        if d = Length(ser.depths) then
          new:=LiftClassesEANonsolvCentralOfOrder(mpcgs,i,hom,pcisom,solvtriv,order);
        else
          new:=LiftClassesEANonsolvCentral(mpcgs,i,hom,pcisom,solvtriv);
        fi;
      elif Length(fants)>0 and Order(i[1])=1 then
        # special case for trivial representative
        ##new:=LiftClassesEATrivRep(mpcgs,i,fants,hom,pcisom,solvtriv);
        if d = Length(ser.depths) then
          new:=LiftClassesEATrivRepOfOrder(mpcgs,i,fants,hom,pcisom,solvtriv,order);
        else
          new:=LiftClassesEATrivRep(mpcgs,i,fants,hom,pcisom,solvtriv);
        fi;
        if new=fail then
          ##new:=LiftClassesEANonsolvGeneral(mpcgs,i,hom,pcisom,solvtriv);
          if d = Length(ser.depths) then
            new:=LiftClassesEANonsolvGeneralOfOrder(mpcgs,i,hom,pcisom,solvtriv,order);
          else
            new:=LiftClassesEANonsolvGeneral(mpcgs,i,hom,pcisom,solvtriv);
          fi;
        fi;
      ##else
        ##new:=LiftClassesEANonsolvGeneral(mpcgs,i,hom,pcisom,solvtriv);
      ##fi;
      elif d = Length(ser.depths) then
        new:=LiftClassesEANonsolvGeneralOfOrder(mpcgs,i,hom,pcisom,solvtriv,order);
      else
        new:=LiftClassesEANonsolvGeneral(mpcgs,i,hom,pcisom,solvtriv);
      fi;
      #Assert(3,ForAll(new,x->x[6]
      #  =Size(Group(Concatenation(x[2],DenominatorOfModuloPcgs(mpcgs))))));

#if ForAny(new,x->x[2]<>TFMakeInducedPcgsModulo(pcgs,x[2],nran)) then Error("HUH6");fi;
#Print(List(new,x->List(x[2],y->DepthOfPcElement(pcgs,y))),"\n");

      #Assert(1,ForAll(new, i->ForAll(GeneratorsOfGroup(i[2]),j->Comm(j,i[1]) in N)));
      ncl:=Concatenation(ncl,new);
      Info(InfoHomClass,2,Length(new)," new classes (",Length(ncl)," total)");
    od;
    cl:=ncl;
    Info(InfoHomClass,1,"Now: ",Length(cl)," classes (",Length(ncl)," total)");
  od;

  ## if Order(cl[1][1])>1 then
  if Order(cl[1])>1 then
    # the identity is not in first position
    Info(InfoHomClass,2,"identity not first, sorting");
    ## SortBy(cl,a->Order(a[1]));
    SortBy(cl,a->Order(a));
  fi;

  Info(InfoHomClass,1,"forming classes");
  ncl:=[];
  for i in cl do
  ##   if IsInt(i[2]) then
  ##     r:=ConjugacyClass(G,i[1]);
  ##     SetSize(r,Size(G)/i[2]);
  ##   else
  ##     d:=SubgroupByFittingFreeData(G,i[3],i[4],i[2]);
  ##     Assert(2,Size(d)=i[5]);
  ##     Assert(2,Centralizer(G,i[1]:usebacktrack)=d);
  ##     SetSize(d,i[5]);
  ##     r:=ConjugacyClass(G,i[1],d);
  ##     SetSize(r,Size(G)/i[5]);
  ##   fi;
  ##   Add(ncl,r);
    Add(ncl, ConjugacyClass(G, i));
  od;

  # as this test is cheap, do it always
  ## if Sum(ncl,Size)<>Size(G) then
  ##   Error("wrong classes");
  ## fi;

  cl:=ncl;

  return cl;
end;

ConjugacyClassesOfOrder := function( G, order )
local cl;
  cl:=ConjugacyClassesForSmallGroup(G);
  if cl<>fail then
    ##return cl;
    return Filtered(cl, c -> Order(Representative(c))=order);
  elif IsSolvableGroup( G ) and CanEasilyComputePcgs(G) then
    ##return ConjugacyClassesForSolvableGroup(G);
    return Filtered(ConjugacyClassesForSolvableGroup(G), c -> Order(Representative(c))=order);
  elif IsNonabelianSimpleGroup( G ) then
    cl:=ClassesFromClassical(G);
    if cl=fail then
      cl:=ConjugacyClassesByRandomSearch( G );
    fi;
    ##return cl;
    return Filtered(cl, c -> Order(Representative(c))=order);
  else
    ##return ConjugacyClassesViaRadical(G);
    return ConjugacyClassesOfOrderViaRadical(G, order);
  fi;
end;