use std::{collections::VecDeque, sync::Arc};

use qter_core::{
    architectures::{Permutation, PermutationGroup},
    discrete_math::chinese_remainder_theorem,
    Facelets, Instruction, Int, PermuteCube, Program, RegisterGenerator, Span, U,
};

/// Represents an instance of a `PermutationGroup`, in other words this simulates the rubik's cube
pub struct Puzzle {
    group: Arc<PermutationGroup>,
    state: Permutation,
}

impl Puzzle {
    /// Initialize the `Puzzle` in the solved state
    pub fn initialize(group: Arc<PermutationGroup>) -> Puzzle {
        Puzzle {
            state: group.identity(),
            group,
        }
    }

    /// Check whether the given facelets are solved
    pub fn facelets_solved(&self, facelets: &[usize]) -> bool {
        for facelet in facelets {
            let maps_to = self.state().mapping()[*facelet];
            if self.group.facelet_colors()[maps_to] != self.group.facelet_colors()[*facelet] {
                return false;
            }
        }

        true
    }

    /// Decode the permutation using the register generator and the given facelets.
    ///
    /// In general, an arbitrary scramble cannot be decoded. If this is the case, the function will return `None`.
    pub fn decode(&self, facelets: &[usize], generator: &PermuteCube) -> Option<Int<U>> {
        chinese_remainder_theorem(facelets.iter().map(|facelet| {
            let maps_to = self.state().mapping()[*facelet];

            let chromatic_order = generator.chromatic_orders_by_facelets()[*facelet];

            if maps_to == *facelet {
                return Some((Int::zero(), chromatic_order));
            }

            let mut i = Int::<U>::one();
            let mut maps_to_found_at = None;
            let mut facelet_at = generator.permutation().mapping()[*facelet];

            while facelet_at != *facelet {
                if facelet_at == maps_to {
                    maps_to_found_at = Some(i);
                    break;
                }

                facelet_at = generator.permutation().mapping()[facelet_at];
                i += Int::<U>::one();
            }

            maps_to_found_at.map(|found_at| (found_at % chromatic_order, chromatic_order))
        }))
    }

    /// Get the underlying `PermutationGroup` of the puzzle
    pub fn group(&self) -> &PermutationGroup {
        &self.group
    }

    /// Get the current state of the puzzle
    pub fn state(&self) -> &Permutation {
        &self.state
    }
}

/// If the interpreter is paused, this represents the reason why.
pub enum PausedState<'s> {
    Halt {
        message: &'s str,
        register_idx: usize,
        register: RegisterGenerator,
    },
    Input {
        message: &'s str,
        register_idx: usize,
        register: RegisterGenerator,
    },
    Panicked(&'static str),
}

/// Whether the interpreter can be stepped forward or is paused for some reason
pub enum StateTy<'s> {
    Running,
    Paused(PausedState<'s>),
}

/// The current execution state of the interpreter
pub struct State<'s> {
    span: Span,
    instruction: usize,
    state_ty: StateTy<'s>,
}

/// An instance of a theoretical register. Analagous to the `Puzzle` structure.
struct TheoreticalState {
    state: Int<U>,
    order: Int<U>,
}

/// A collection of the states of every register
///
/// Factored out for borrow checker reasons
struct GroupStates {
    theoretical_states: Vec<TheoreticalState>,
    puzzle_states: Vec<Puzzle>,
}

/// Represents messages generated by the interpreter
///
/// Factored out for borrow checker reasons
struct Messaging {
    messages: VecDeque<String>,
    panicked: Option<&'static str>,
    paused: bool,
}

/// An interpreter for a qter program
pub struct Interpreter {
    group_state: GroupStates,
    instruction_counter: usize,
    program: Program,
    messaging: Messaging,
}

/// The action performed by the instruction that was just executed
pub enum ActionPerformed<'s> {
    None,
    Paused,
    Goto {
        location: usize,
    },
    FailedSolvedGoto {
        register_idx: usize,
        facelets: &'s Facelets,
    },
    SucceededSolvedGoto {
        register_idx: usize,
        facelets: &'s Facelets,
        location: usize,
    },
    AddToTheoretical {
        register_idx: usize,
        amt: Int<U>,
    },
    ExecutedAlgorithm(&'s PermuteCube),
    Panic(&'static str),
}

impl GroupStates {
    /// Check whether a register is solved
    fn is_register_solved(&self, register_idx: usize, which_reg: &Facelets) -> bool {
        match which_reg {
            Facelets::Theoretical => self.theoretical_states[register_idx].state.is_zero(),
            Facelets::Puzzle { facelets } => {
                let puzzle = &self.puzzle_states[register_idx];
                puzzle.facelets_solved(facelets)
            }
        }
    }

    /// Decode a register
    fn decode_register(
        &self,
        register_idx: usize,
        which_reg: &RegisterGenerator,
    ) -> Option<Int<U>> {
        match which_reg {
            RegisterGenerator::Theoretical => Some(self.theoretical_states[register_idx].state),
            RegisterGenerator::Puzzle {
                generator,
                facelets,
            } => {
                let puzzle = &self.puzzle_states[register_idx];
                puzzle.decode(facelets, generator)
            }
        }
    }

    /// Explicitly add a number to a register
    fn add_num_to(&mut self, register_idx: usize, which_reg: &RegisterGenerator, amt: Int<U>) {
        match which_reg {
            RegisterGenerator::Theoretical => {
                let TheoreticalState { state, order } = &mut self.theoretical_states[register_idx];

                assert!(amt < *order);

                *state += amt;

                if *state >= *order {
                    *state -= *order;
                }
            }
            RegisterGenerator::Puzzle {
                generator,
                facelets: _,
            } => {
                let puzzle = &mut self.puzzle_states[register_idx];
                let mut perm = generator.permutation().to_owned();

                perm.exponentiate(amt);

                puzzle.state.compose(&perm);
            }
        }
    }

    /// Compose a permutation into a puzzle state
    fn compose_into(&mut self, puzzle_idx: usize, permutation: &Permutation) {
        self.puzzle_states[puzzle_idx].state.compose(permutation);
    }
}

impl Messaging {
    fn panic(&mut self, message: &'static str) -> ActionPerformed<'static> {
        self.panicked = Some(message);
        self.paused = true;
        self.messages.push_back(format!("Panicked: {message}"));
        ActionPerformed::Panic(message)
    }
}

impl Interpreter {
    /// Create a new interpreter from a program and initial states for registers
    ///
    /// If an initial state isn't specified, it defaults to zero.
    pub fn new(program: Program) -> Interpreter {
        let theoretical_states = program
            .theoretical
            .iter()
            .map(|order| TheoreticalState {
                state: Int::zero(),
                order: **order,
            })
            .collect();

        let puzzle_states = program
            .puzzles
            .iter()
            .map(|group| Puzzle::initialize(Arc::clone(group)))
            .collect();

        Interpreter {
            group_state: GroupStates {
                theoretical_states,
                puzzle_states,
            },
            program,
            instruction_counter: 0,
            messaging: Messaging {
                messages: VecDeque::new(),
                panicked: None,
                paused: false,
            },
        }
    }

    /// Get the current state of the interpreter
    pub fn state(&self) -> State<'_> {
        let idx = if self.instruction_counter >= self.program.instructions.len() {
            self.program.instructions.len() - 1
        } else {
            self.instruction_counter
        };

        let instruction = &self.program.instructions[idx];

        let state_ty = if let Some(message) = &self.messaging.panicked {
            StateTy::Paused(PausedState::Panicked(message))
        } else {
            match &**instruction {
                Instruction::Halt {
                    message,
                    register,
                    register_idx,
                } => StateTy::Paused(PausedState::Halt {
                    message,
                    register: register.to_owned(),
                    register_idx: *register_idx,
                }),
                Instruction::Input {
                    message,
                    register,
                    register_idx,
                } => StateTy::Paused(PausedState::Input {
                    message,
                    register: register.to_owned(),
                    register_idx: *register_idx,
                }),
                _ => StateTy::Running,
            }
        };

        State {
            span: instruction.span().to_owned(),
            instruction: idx,
            state_ty,
        }
    }

    /// Execute one instruction
    pub fn step(&mut self) -> ActionPerformed<'_> {
        let instruction = match self.program.instructions.get(self.instruction_counter) {
            Some(v) => v,
            None => {
                return self
                    .messaging
                    .panic("Execution fell through the end of the program without reaching a halt instruction!");
            }
        };

        match &**instruction {
            Instruction::Goto { instruction_idx } => {
                self.instruction_counter = *instruction_idx;

                ActionPerformed::Goto {
                    location: *instruction_idx,
                }
            }
            Instruction::SolvedGoto {
                instruction_idx,
                facelets,
                register_idx,
            } => {
                if self.group_state.is_register_solved(*register_idx, facelets) {
                    self.instruction_counter = *instruction_idx;

                    ActionPerformed::SucceededSolvedGoto {
                        facelets,
                        location: *instruction_idx,
                        register_idx: *register_idx,
                    }
                } else {
                    self.instruction_counter += 1;

                    ActionPerformed::FailedSolvedGoto {
                        facelets,
                        register_idx: *register_idx,
                    }
                }
            }
            Instruction::Input {
                message,
                register: _,
                register_idx: _,
            } => {
                if !self.messaging.paused {
                    self.messaging.paused = true;
                    self.messaging.messages.push_back(message.to_owned());
                }

                ActionPerformed::Paused
            }
            Instruction::Halt {
                message,
                register,
                register_idx,
            } => {
                let decoded = match self.group_state.decode_register(*register_idx, register) {
                    Some(v) => v,
                    None => {
                        return self
                            .messaging
                            .panic("The register specified is not decodable!");
                    }
                };

                if !self.messaging.paused {
                    self.messaging.paused = true;
                    self.messaging
                        .messages
                        .push_back(format!("{message} {decoded}",));
                }

                ActionPerformed::Paused
            }
            Instruction::Print {
                message,
                register,
                register_idx,
            } => {
                let decoded = match self.group_state.decode_register(*register_idx, register) {
                    Some(v) => v,
                    None => {
                        return self
                            .messaging
                            .panic("The register specified is not decodable!");
                    }
                };

                self.messaging
                    .messages
                    .push_back(format!("{message} {decoded}"));

                self.instruction_counter += 1;

                ActionPerformed::None
            }
            Instruction::AddTheoretical {
                register_idx,
                amount,
            } => {
                let reg = RegisterGenerator::Theoretical;

                self.group_state.add_num_to(*register_idx, &reg, *amount);

                self.instruction_counter += 1;

                ActionPerformed::AddToTheoretical {
                    register_idx: *register_idx,
                    amt: *amount,
                }
            }
            Instruction::PermuteCube {
                permutation: permute_cube,
                cube_idx,
            } => {
                self.group_state
                    .compose_into(*cube_idx, permute_cube.permutation());

                self.instruction_counter += 1;

                ActionPerformed::ExecutedAlgorithm(permute_cube)
            }
        }
    }

    /// Get the message queue of the interpreter
    pub fn messages(&mut self) -> &mut VecDeque<String> {
        &mut self.messaging.messages
    }

    /// Execute instructions until an input or halt instruction is reached
    ///
    /// Returns details of the paused state reached
    pub fn step_until_halt(&mut self) -> PausedState<'_> {
        while !self.messaging.paused {
            self.step();
        }

        match self.state().state_ty {
            StateTy::Running => panic!("Cannot be halted while running"),
            StateTy::Paused(v) => v,
        }
    }

    /// Give an input to the interpreter
    ///
    /// Panics if the interpreter is not executing an `input` instruction
    pub fn give_input(&mut self, value: Int<U>) {
        let reg = match self.state().state_ty {
            StateTy::Paused(PausedState::Input {
                message: _,
                register,
                register_idx,
            }) => (register_idx, register),
            _ => panic!("The interpreter isn't in an input state"),
        };

        self.group_state.add_num_to(reg.0, &reg.1, value);

        self.messaging.paused = false;
        self.instruction_counter += 1;
    }
}

#[cfg(test)]
mod tests {
    use std::sync::Arc;

    use compiler::compile;
    use internment::ArcIntern;
    use qter_core::{
        architectures::PuzzleDefinition, Facelets, Instruction, Int, PermuteCube, Program,
        RegisterGenerator, Span, WithSpan, U,
    };

    use crate::{Interpreter, PausedState, Puzzle};

    #[test]
    fn facelets_solved() {
        let group = Arc::new(
            PuzzleDefinition::parse(include_str!("../../qter_core/puzzles/3x3.txt")).unwrap(),
        );

        let mut cube = Puzzle::initialize(Arc::clone(&group.group));

        // Remember that the decoder will subtract the smallest facelet found in the definition to make it zero based
        assert!(cube.facelets_solved(&[0, 8, 16, 24]));

        group
            .group
            .compose_generators_into(&mut cube.state, [ArcIntern::from_ref("U")].iter())
            .unwrap();

        assert!(cube.facelets_solved(&[0, 12, 15, 7, 40]));

        assert!(!cube.facelets_solved(&[1, 12, 15, 7, 24]));
    }

    #[test]
    fn decode() {
        let group = Arc::new(
            PuzzleDefinition::parse(include_str!("../../qter_core/puzzles/3x3.txt")).unwrap(),
        );

        let mut cube = Puzzle::initialize(Arc::clone(&group.group));

        let permutation = PermuteCube::new_from_generators(
            Arc::clone(&group.group),
            vec![ArcIntern::from_ref("U")],
        )
        .unwrap();

        assert_eq!(cube.decode(&[8], &permutation).unwrap(), Int::<U>::zero());
        assert!(cube.facelets_solved(&[8]));

        cube.state.compose(permutation.permutation());
        assert_eq!(cube.decode(&[8], &permutation).unwrap(), Int::<U>::one());
        assert!(!cube.facelets_solved(&[8]));

        cube.state.compose(permutation.permutation());
        assert_eq!(cube.decode(&[8], &permutation).unwrap(), Int::from(2));
        assert!(!cube.facelets_solved(&[8]));

        cube.state.compose(permutation.permutation());
        assert_eq!(cube.decode(&[8], &permutation).unwrap(), Int::from(3));
        assert!(!cube.facelets_solved(&[8]));

        cube.state.compose(permutation.permutation());
        assert_eq!(cube.decode(&[8], &permutation).unwrap(), Int::from(0));
        assert!(cube.facelets_solved(&[8]));
    }

    #[test]
    fn complicated_solved_decode_test() {
        let group = Arc::new(
            PuzzleDefinition::parse(include_str!("../../qter_core/puzzles/3x3.txt")).unwrap(),
        );

        let arch = group
            .get_preset(&[Int::from(210_u64), Int::from(24_u64)])
            .unwrap();

        let a_facelets = arch.registers()[0].signature_facelets();
        let b_facelets = arch.registers()[1].signature_facelets();

        let a_permutation = PermuteCube::new_from_effect(&arch, vec![(0, Int::one())]);
        let b_permutation = PermuteCube::new_from_effect(&arch, vec![(1, Int::one())]);

        let mut cube = Puzzle::initialize(Arc::clone(&group.group));

        for i in 1..=23 {
            cube.state.compose(b_permutation.permutation());
            assert_eq!(
                cube.decode(&b_facelets, &b_permutation).unwrap(),
                Int::from(i)
            );
            assert!(!cube.facelets_solved(&b_facelets));
        }

        cube.state.compose(b_permutation.permutation());
        assert!(cube.facelets_solved(&b_facelets));
        assert_eq!(
            cube.decode(&b_facelets, &b_permutation).unwrap(),
            Int::<U>::zero()
        );

        for i in 0..24 {
            for j in 0..210 {
                assert_eq!(
                    cube.decode(&b_facelets, &b_permutation).unwrap(),
                    Int::from(i)
                );
                assert_eq!(
                    cube.decode(&a_facelets, &a_permutation).unwrap(),
                    Int::from(j)
                );

                cube.state.compose(a_permutation.permutation());
            }

            cube.state.compose(b_permutation.permutation());
        }
    }

    #[test]
    fn modulus() {
        let code = "
            .registers {
                B, A ← 3x3 builtin (24, 210)
            }

                input \"Number to modulus:\" A
            loop:
                print \"A is now\" A
                add B 13
            decrement:
                solved-goto B loop
                solved-goto A fix
                add A 209
                add B 23
                goto decrement
            fix:
                solved-goto B finalize
                add A 209
                add B 23
                goto fix
            finalize:
                add A 13
                halt \"The modulus is\" A
        ";

        let program = match compile(code, |_| unreachable!()) {
            Ok(v) => v,
            Err(e) => panic!("{e}"),
        };

        let mut interpreter = Interpreter::new(program);

        assert!(matches!(
            interpreter.step_until_halt(),
            PausedState::Input {
                message: "Number to modulus:",
                register: RegisterGenerator::Puzzle {
                    generator: _,
                    facelets: _
                },
                register_idx: 0,
            }
        ));

        interpreter.give_input(Int::from(133_u64));

        assert!(matches!(
            interpreter.step_until_halt(),
            PausedState::Halt {
                message: "The modulus is",
                register: RegisterGenerator::Puzzle {
                    generator: _,
                    facelets: _
                },
                register_idx: 0,
            }
        ));

        let expected_output = [
            "Number to modulus:",
            "A is now 133",
            "A is now 120",
            "A is now 107",
            "A is now 94",
            "A is now 81",
            "A is now 68",
            "A is now 55",
            "A is now 42",
            "A is now 29",
            "A is now 16",
            "A is now 3",
            "The modulus is 3",
        ];

        assert_eq!(
            expected_output.len(),
            interpreter.messages().len(),
            "{:?}",
            interpreter.messages()
        );

        for (message, expected) in interpreter
            .messaging
            .messages
            .iter()
            .zip(expected_output.iter())
        {
            assert_eq!(message, expected);
        }
    }

    #[test]
    fn fib() {
        // TODO: a test directory of qat files?
        let code = "
            .registers {
                D, C, B, A ← 3x3 builtin (9, 10, 18, 30)
            }

                input \"Which Fibonacci number to calculate:\" D
                solved-goto D do_if_1
                goto after_if_1
            do_if_1:
                halt \"The number is\" A
            after_if_1:
                add B 1
            continue_1:
                add D 8
                solved-goto D do_if_2
                goto after_if_2
            do_if_2:
                halt \"The number is\" B
            after_if_2:
            continue_2:
                solved-goto B break_2
                add B 17
                add A 1
                add C 1
                goto continue_2
            break_2:
                add D 8
                solved-goto D do_if_3
                goto after_if_3
            do_if_3:
                halt \"The number is\" A
            after_if_3:
            continue_3:
                solved-goto A break_3
                add A 29
                add C 1
                add B 1
                goto continue_3
            break_3:
                add D 8
                solved-goto D do_if_4
                goto after_if_4
            do_if_4:
                halt \"The number is\" C
            after_if_4:
            continue_4:
                solved-goto C break_4
                add C 9
                add B 1
                add A 1
                goto continue_4
            break_4:
                goto continue_1
        ";

        let program = match compile(code, |_| unreachable!()) {
            Ok(v) => v,
            Err(e) => panic!("{e}"),
        };

        let mut interpreter = Interpreter::new(program);

        assert!(matches!(
            interpreter.step_until_halt(),
            PausedState::Input {
                message: "Which Fibonacci number to calculate:",
                register: RegisterGenerator::Puzzle {
                    generator: _,
                    facelets: _
                },
                register_idx: 0,
            }
        ));

        interpreter.give_input(Int::from(8_u64));

        assert!(matches!(
            interpreter.step_until_halt(),
            PausedState::Halt {
                message: "The number is",
                register: RegisterGenerator::Puzzle {
                    generator: _,
                    facelets: _
                },
                register_idx: 0,
            }
        ));

        let expected_output = ["Which Fibonacci number to calculate:", "The number is 21"];

        assert_eq!(
            expected_output.len(),
            interpreter.messages().len(),
            "{:?}",
            interpreter.messages()
        );

        for (message, expected) in interpreter
            .messaging
            .messages
            .iter()
            .zip(expected_output.iter())
        {
            assert_eq!(message, expected);
        }
    }
}
