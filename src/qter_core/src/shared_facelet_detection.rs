use std::{cell::RefCell, collections::HashSet, sync::Arc};

use internment::ArcIntern;
use itertools::Itertools;

use crate::{
    architectures::{CycleGenerator, CycleGeneratorSubcycle, Permutation, PermutationGroup},
    discrete_math::{lcm, length_of_substring_that_this_string_is_n_repeated_copies_of},
    Int,
};

#[derive(Debug)]
enum UnionFindEntry {
    RootOfSet {
        // For weighted union-find
        weight: usize,
        // Which algorithms share the facelets in this set?
        contains_facelets_from: HashSet<usize>,
    },
    OwnedBy(RefCell<usize>),
}

/// A union-find for which facelets belong to which algorithm
#[derive(Debug)]
struct UnionFindOfCycles {
    sets: Vec<UnionFindEntry>,
}

impl UnionFindOfCycles {
    /// Returns the index of the root entry representing the facelet's orbit as well as the number of facelets and the set of algorithms that contribute to the facelet's orbit
    fn find(&self, facelet: usize) -> (usize, (usize, &HashSet<usize>)) {
        match &self.sets[facelet] {
            UnionFindEntry::RootOfSet {
                weight,
                contains_facelets_from,
            } => (facelet, (*weight, contains_facelets_from)),
            UnionFindEntry::OwnedBy(parent_idx) => {
                let ret = self.find(*parent_idx.borrow());
                *(parent_idx.borrow_mut()) = ret.0;
                ret
            }
        }
    }

    // Unions two facelets along with the sets of algorithms that they belong to
    fn union(&mut self, a: usize, b: usize) {
        let (root_a, (weight_a, sets_a)) = self.find(a);
        let (root_b, (weight_b, sets_b)) = self.find(b);

        let mut combined_sets = sets_a.to_owned();
        combined_sets.extend(sets_b);

        if root_a == root_b {
            return;
        }

        if weight_a > weight_b {
            match &mut self.sets[root_a] {
                UnionFindEntry::RootOfSet {
                    weight,
                    contains_facelets_from,
                } => {
                    *weight += weight_b;
                    *contains_facelets_from = combined_sets;
                }
                UnionFindEntry::OwnedBy(_) => unreachable!(),
            }

            self.sets[root_b] = UnionFindEntry::OwnedBy(RefCell::new(root_a));
        } else {
            match &mut self.sets[root_b] {
                UnionFindEntry::RootOfSet {
                    weight,
                    contains_facelets_from,
                } => {
                    *weight += weight_a;
                    *contains_facelets_from = combined_sets;
                }
                UnionFindEntry::OwnedBy(_) => unreachable!(),
            }

            self.sets[root_a] = UnionFindEntry::OwnedBy(RefCell::new(root_b));
        }
    }

    /// Calculate the orbits of all of the facelets along with which algorithms contribute to the orbit
    fn find_orbits(facelet_count: usize, permutations: &[Permutation]) -> UnionFindOfCycles {
        // Initialize the union-find
        let mut sets = vec![];

        for facelet in 0..facelet_count {
            // For each facelet, find which algorithms move it and add them to the set
            let mut contains_facelets_from = HashSet::new();

            for (i, permutation) in permutations.iter().enumerate() {
                if permutation.mapping()[facelet] != facelet {
                    contains_facelets_from.insert(i);
                }
            }

            sets.push(UnionFindEntry::RootOfSet {
                weight: 1,
                contains_facelets_from,
            })
        }

        let mut union_find = UnionFindOfCycles { sets };

        // Union all facelets that share the same orbit
        for permutation in permutations {
            for facelet in 0..facelet_count {
                let goes_to = permutation.mapping()[facelet];

                // They have the same orbit if one is mapped to the other
                union_find.union(facelet, goes_to);
            }
        }

        union_find
    }
}

/// Convert the algorithms into a list of cycle generators and a list of shared facelets
pub fn algorithms_to_cycle_generators(
    group: Arc<PermutationGroup>,
    algorithms: &[Vec<ArcIntern<String>>],
) -> Result<(Vec<CycleGenerator>, Vec<usize>), ArcIntern<String>> {
    // Calculate the permutations generated by each algorithm
    let mut permutations = vec![];

    for algorithm in algorithms {
        let mut permutation = group.identity();
        group.compose_generators_into(&mut permutation, algorithm.iter())?;
        permutations.push(permutation);
    }

    // Find the orbits of all of the facelets in the subgroup generated by `permutations`
    let orbits = UnionFindOfCycles::find_orbits(group.facelet_count(), &permutations);

    let mut shared_facelets = vec![];

    Ok((
        permutations
            .into_iter()
            .zip(algorithms.iter())
            .map(|(permutation, algorithm)| {
                // Dump all unshared facelets out of the union-find into a list and all shared facelets into the shared_facelets list
                let mut unshared_cycles = vec![];

                for cycle in permutation.cycles() {
                    if orbits.find(cycle[0]).1 .1.len() > 1 {
                        shared_facelets.extend_from_slice(cycle);
                        continue;
                    }

                    let chromatic_order =
                        length_of_substring_that_this_string_is_n_repeated_copies_of(
                            cycle.iter().map(|v| &**group.facelet_colors()[*v]),
                        );

                    unshared_cycles.push(CycleGeneratorSubcycle {
                        facelet_cycle: cycle.to_owned(),
                        chromatic_order: Int::from(chromatic_order),
                    });
                }

                CycleGenerator {
                    generator_sequence: algorithm.to_owned(),
                    permutation,
                    order: unshared_cycles
                        .iter()
                        .fold(Int::one(), |a, v| lcm(a, v.chromatic_order)),
                    unshared_cycles,
                    group: Arc::clone(&group),
                }
            })
            .collect(),
        shared_facelets.into_iter().unique().collect_vec(),
    ))
}

#[cfg(test)]
mod tests {
    use crate::{
        architectures::{CycleGeneratorSubcycle, PuzzleDefinition},
        Int,
    };

    #[test]
    fn simple() {
        let PuzzleDefinition { group: _, presets } = PuzzleDefinition::parse(
            "
                COLORS

                A -> 1
                B -> 2
                C -> 3
                D -> 4
                E -> 5
                F -> 6
                G -> 7
                H -> 8
                I -> 9
                J -> 10
                K -> 11, 12, 13

                GENERATORS

                A = (1, 2, 3)
                B = (4, 5, 6)
                C = (6, 7, 8)
                D = (9, 10)
                E = (11, 12, 13)

                DERIVED

                PRESETS

                (3, 2) A B / C D E
            ",
        )
        .unwrap();

        let preset = &presets[0];

        for i in 3..=7 {
            assert!(preset.shared_facelets().contains(&i));
        }

        assert_eq!(preset.registers()[0].order, Int::from(3));
        assert_eq!(
            preset.registers()[0].unshared_cycles,
            vec![CycleGeneratorSubcycle {
                facelet_cycle: vec![0, 1, 2],
                chromatic_order: Int::from(3_usize),
            }]
        );
        assert_eq!(preset.registers()[1].order, Int::from(2));
        assert_eq!(
            preset.registers()[1].unshared_cycles,
            vec![
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![8, 9],
                    chromatic_order: Int::from(2_usize)
                },
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![10, 11, 12],
                    chromatic_order: Int::one(),
                }
            ]
        );
    }
}
