use std::{collections::HashSet, sync::Arc};

use internment::ArcIntern;
use itertools::Itertools;

use crate::{
    Int,
    architectures::{
        Algorithm, CycleGenerator, CycleGeneratorSubcycle, Permutation, PermutationGroup,
    },
    discrete_math::length_of_substring_that_this_string_is_n_repeated_copies_of,
    union_find::{SetInfo, UnionFind},
};

struct FaceletSources(HashSet<usize>);

impl SetInfo for FaceletSources {
    type PathInfo = ();

    const ALLOW_WEIGHTED: bool = true;

    fn merge(&mut self, new_child: Self) -> Self::PathInfo {
        self.0.extend(new_child.0);
    }

    fn join_paths(_path: &mut Self::PathInfo, _path_of_parent: &Self::PathInfo) {}
}

/// Calculate the orbits of all of the facelets along with which algorithms contribute to the orbit
fn find_orbits(facelet_count: usize, permutations: &[Permutation]) -> UnionFind<FaceletSources> {
    // Initialize the union-find
    let mut sets = vec![];

    for facelet in 0..facelet_count {
        // For each facelet, find which algorithms move it and add them to the set
        let mut contains_facelets_from = HashSet::new();

        for (i, permutation) in permutations.iter().enumerate() {
            if permutation.mapping()[facelet] != facelet {
                contains_facelets_from.insert(i);
            }
        }

        sets.push(FaceletSources(contains_facelets_from));
    }

    let mut union_find = UnionFind::new_with_initial_set_info(sets);

    // Union all facelets that share the same orbit
    for permutation in permutations {
        for facelet in 0..facelet_count {
            let goes_to = permutation.mapping()[facelet];

            // They have the same orbit if one is mapped to the other
            union_find.union(facelet, goes_to, ());
        }
    }

    union_find
}

/// Convert the algorithms into a list of cycle generators and a list of shared facelets
///
/// # Errors
///
/// If either of the algorithms have an invalid generator, the function will compose all of the generators before it and return the name of the generator that doesn't exist as an error
pub fn algorithms_to_cycle_generators(
    group: &Arc<PermutationGroup>,
    algorithms: &[Vec<ArcIntern<str>>],
) -> Result<(Vec<CycleGenerator>, Vec<usize>), ArcIntern<str>> {
    // Calculate the permutations generated by each algorithm
    let mut permutations = vec![];

    for algorithm in algorithms {
        let mut permutation = group.identity();
        group.compose_generators_into(&mut permutation, algorithm.iter())?;
        permutations.push(permutation);
    }

    // Find the orbits of all of the facelets in the subgroup generated by `permutations`
    let orbits = find_orbits(group.facelet_count(), &permutations);

    let mut shared_facelets = vec![];

    Ok((
        permutations
            .into_iter()
            .zip(algorithms.iter())
            .map(|(permutation, algorithm)| {
                // Dump all unshared facelets out of the union-find into a list and all shared facelets into the shared_facelets list
                let mut unshared_cycles = vec![];

                for cycle in permutation.cycles() {
                    if orbits.find(cycle[0]).set_meta().0.len() > 1 {
                        shared_facelets.extend_from_slice(cycle);
                        continue;
                    }

                    let chromatic_order =
                        length_of_substring_that_this_string_is_n_repeated_copies_of(
                            cycle.iter().map(|&idx| &*group.facelet_colors()[idx]),
                        );

                    unshared_cycles.push(CycleGeneratorSubcycle {
                        facelet_cycle: cycle.to_owned(),
                        chromatic_order: Int::from(chromatic_order),
                    });
                }

                CycleGenerator::new(
                    Algorithm::new_from_move_seq(Arc::clone(group), algorithm.to_owned()).unwrap(),
                    unshared_cycles,
                )
            })
            .collect(),
        shared_facelets.into_iter().unique().collect_vec(),
    ))
}

#[cfg(test)]
mod tests {
    use std::{collections::HashMap, sync::Arc};

    use internment::ArcIntern;

    use crate::{
        Int,
        architectures::{Architecture, CycleGeneratorSubcycle, Permutation, PermutationGroup},
    };

    #[test]
    fn simple() {
        let mut generators = HashMap::new();

        generators.insert(
            ArcIntern::from("A"),
            Permutation::from_cycles(vec![vec![0, 1, 2]]),
        );
        generators.insert(
            ArcIntern::from("B"),
            Permutation::from_cycles(vec![vec![3, 4, 5]]),
        );
        generators.insert(
            ArcIntern::from("C"),
            Permutation::from_cycles(vec![vec![5, 6, 7]]),
        );
        generators.insert(
            ArcIntern::from("D"),
            Permutation::from_cycles(vec![vec![8, 9]]),
        );
        generators.insert(
            ArcIntern::from("E"),
            Permutation::from_cycles(vec![vec![10, 11, 12]]),
        );
        generators.insert(
            ArcIntern::from("A'"),
            Permutation::from_cycles(vec![vec![2, 1, 0]]),
        );
        generators.insert(
            ArcIntern::from("B'"),
            Permutation::from_cycles(vec![vec![5, 4, 3]]),
        );
        generators.insert(
            ArcIntern::from("C'"),
            Permutation::from_cycles(vec![vec![7, 6, 5]]),
        );
        generators.insert(
            ArcIntern::from("E'"),
            Permutation::from_cycles(vec![vec![12, 11, 10]]),
        );

        let perm_group = Arc::new(PermutationGroup::new(
            vec![
                ArcIntern::from("A"),
                ArcIntern::from("B"),
                ArcIntern::from("C"),
                ArcIntern::from("D"),
                ArcIntern::from("E"),
                ArcIntern::from("F"),
                ArcIntern::from("G"),
                ArcIntern::from("H"),
                ArcIntern::from("I"),
                ArcIntern::from("J"),
                ArcIntern::from("K"),
                ArcIntern::from("K"),
                ArcIntern::from("K"),
            ],
            generators,
        ));

        let preset = Architecture::new(
            perm_group,
            &[
                vec![ArcIntern::from("A"), ArcIntern::from("B")],
                vec![
                    ArcIntern::from("C"),
                    ArcIntern::from("D"),
                    ArcIntern::from("E"),
                ],
            ],
        )
        .unwrap();

        for i in 3..=7 {
            assert!(preset.shared_facelets().contains(&i));
        }

        assert_eq!(preset.registers()[0].order(), Int::from(3));
        assert_eq!(
            preset.registers()[0].unshared_cycles(),
            vec![CycleGeneratorSubcycle {
                facelet_cycle: vec![0, 1, 2],
                chromatic_order: Int::from(3_usize),
            }]
        );
        assert_eq!(preset.registers()[1].order(), Int::from(2));
        assert_eq!(
            preset.registers()[1].unshared_cycles(),
            vec![
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![8, 9],
                    chromatic_order: Int::from(2_usize)
                },
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![10, 11, 12],
                    chromatic_order: Int::one(),
                }
            ]
        );
    }
}
