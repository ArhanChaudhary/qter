use std::{collections::HashSet, sync::Arc};

use internment::ArcIntern;
use itertools::Itertools;

use crate::{
    Int,
    architectures::{
        Algorithm, CycleGenerator, CycleGeneratorSubcycle, Permutation, PermutationGroup,
    },
    discrete_math::{lcm, length_of_substring_that_this_string_is_n_repeated_copies_of},
    union_find::{SetInfo, UnionFind},
};

struct FaceletSources(HashSet<usize>);

impl SetInfo for FaceletSources {
    type PathInfo = ();

    const ALLOW_WEIGHTED: bool = true;

    fn merge(&mut self, new_child: Self) -> Self::PathInfo {
        self.0.extend(new_child.0)
    }

    fn join_paths(_path: &mut Self::PathInfo, _path_of_parent: &Self::PathInfo) {}
}

/// Calculate the orbits of all of the facelets along with which algorithms contribute to the orbit
fn find_orbits(facelet_count: usize, permutations: &[Permutation]) -> UnionFind<FaceletSources> {
    // Initialize the union-find
    let mut sets = vec![];

    for facelet in 0..facelet_count {
        // For each facelet, find which algorithms move it and add them to the set
        let mut contains_facelets_from = HashSet::new();

        for (i, permutation) in permutations.iter().enumerate() {
            if permutation.mapping()[facelet] != facelet {
                contains_facelets_from.insert(i);
            }
        }

        sets.push(FaceletSources(contains_facelets_from))
    }

    let mut union_find = UnionFind::new_with_initial_set_info(sets);

    // Union all facelets that share the same orbit
    for permutation in permutations {
        for facelet in 0..facelet_count {
            let goes_to = permutation.mapping()[facelet];

            // They have the same orbit if one is mapped to the other
            union_find.union(facelet, goes_to);
        }
    }

    union_find
}

/// Convert the algorithms into a list of cycle generators and a list of shared facelets
pub fn algorithms_to_cycle_generators(
    group: Arc<PermutationGroup>,
    algorithms: &[Vec<ArcIntern<str>>],
) -> Result<(Vec<CycleGenerator>, Vec<usize>), ArcIntern<str>> {
    // Calculate the permutations generated by each algorithm
    let mut permutations = vec![];

    for algorithm in algorithms {
        let mut permutation = group.identity();
        group.compose_generators_into(&mut permutation, algorithm.iter())?;
        permutations.push(permutation);
    }

    // Find the orbits of all of the facelets in the subgroup generated by `permutations`
    let orbits = find_orbits(group.facelet_count(), &permutations);

    let mut shared_facelets = vec![];

    Ok((
        permutations
            .into_iter()
            .zip(algorithms.iter())
            .map(|(permutation, algorithm)| {
                // Dump all unshared facelets out of the union-find into a list and all shared facelets into the shared_facelets list
                let mut unshared_cycles = vec![];

                for cycle in permutation.cycles() {
                    if orbits.find(cycle[0]).set_meta().0.len() > 1 {
                        shared_facelets.extend_from_slice(cycle);
                        continue;
                    }

                    let chromatic_order =
                        length_of_substring_that_this_string_is_n_repeated_copies_of(
                            cycle.iter().map(|&idx| &*group.facelet_colors()[idx]),
                        );

                    unshared_cycles.push(CycleGeneratorSubcycle {
                        facelet_cycle: cycle.to_owned(),
                        chromatic_order: Int::from(chromatic_order),
                    });
                }

                CycleGenerator {
                    algorithm: Algorithm::new_from_move_seq(
                        Arc::clone(&group),
                        algorithm.to_owned(),
                    )
                    .unwrap(),
                    order: unshared_cycles.iter().fold(Int::one(), |acc, subcycle| {
                        lcm(acc, subcycle.chromatic_order)
                    }),
                    unshared_cycles,
                }
            })
            .collect(),
        shared_facelets.into_iter().unique().collect_vec(),
    ))
}

#[cfg(test)]
mod tests {
    use crate::{
        Int,
        architectures::{CycleGeneratorSubcycle, PuzzleDefinition},
    };

    #[test]
    fn simple() {
        let PuzzleDefinition {
            perm_group: _,
            presets,
        } = PuzzleDefinition::parse(
            "
                COLORS

                A -> 1
                B -> 2
                C -> 3
                D -> 4
                E -> 5
                F -> 6
                G -> 7
                H -> 8
                I -> 9
                J -> 10
                K -> 11, 12, 13

                GENERATORS

                A = (1, 2, 3)
                B = (4, 5, 6)
                C = (6, 7, 8)
                D = (9, 10)
                E = (11, 12, 13)

                A' = (3, 2, 1)
                B' = (6, 5, 4)
                C' = (8, 7, 6)
                E' = (13, 12, 11)

                DERIVED

                PRESETS

                (3, 2) A B / C D E
            ",
        )
        .unwrap();

        let preset = &presets[0];

        for i in 3..=7 {
            assert!(preset.shared_facelets().contains(&i));
        }

        assert_eq!(preset.registers()[0].order, Int::from(3));
        assert_eq!(
            preset.registers()[0].unshared_cycles,
            vec![CycleGeneratorSubcycle {
                facelet_cycle: vec![0, 1, 2],
                chromatic_order: Int::from(3_usize),
            }]
        );
        assert_eq!(preset.registers()[1].order, Int::from(2));
        assert_eq!(
            preset.registers()[1].unshared_cycles,
            vec![
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![8, 9],
                    chromatic_order: Int::from(2_usize)
                },
                CycleGeneratorSubcycle {
                    facelet_cycle: vec![10, 11, 12],
                    chromatic_order: Int::one(),
                }
            ]
        );
    }
}
