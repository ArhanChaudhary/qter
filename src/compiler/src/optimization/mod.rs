use std::{collections::VecDeque, ptr, sync::Arc};

use qter_core::{
    ByPuzzleType, Int, PuzzleIdx, StateIdx, TheoreticalIdx, U, WithSpan,
    architectures::Architecture,
};

use crate::{
    BlockID, Label, LabelReference, RegisterReference,
    optimization::{
        combinators::{Global, Peephole, RepeatUntilConvergence, push_to_pull},
        global::DeadLabelRemover,
        local::{
            CoalesceAdds, RemoveDeadCode, RemoveUselessJumps, RepeatUntil1, RepeatUntil2,
            RepeatUntil3, TransformSolve,
        },
    },
    strip_expanded::GlobalRegs,
};

mod combinators;
mod global;
mod local;

// Remove when https://doc.rust-lang.org/beta/unstable-book/language-features/deref-patterns.html is stable
#[macro_export]
macro_rules! primitive_match {
    ($pattern:pat = $val:expr) => {
        primitive_match!($pattern = $val; else { return; });
    };

    ($pattern:pat = $val:expr; else $else:block) => {
        let Some(OptimizingCodeComponent::Instruction(instr, _)) = $val.map(|v| &**v) else $else;
        let $pattern = &**instr else $else;
    }
}

fn extend_from_start<T, I: IntoIterator<Item = T>>(deque: &mut VecDeque<T>, iter: I)
where
    I::IntoIter: DoubleEndedIterator,
{
    for item in iter.into_iter().rev() {
        deque.push_front(item);
    }
}

#[derive(Clone, Debug)]
pub enum OptimizingPrimitive {
    AddPuzzle {
        puzzle: PuzzleIdx,
        arch: Arc<Architecture>,
        // register idx, modulus, amt to add
        amts: Vec<(usize, Option<Int<U>>, WithSpan<Int<U>>)>,
    },
    AddTheoretical {
        theoretical: TheoreticalIdx,
        amt: WithSpan<Int<U>>,
    },
    Goto {
        label: WithSpan<LabelReference>,
    },
    SolvedGoto {
        label: WithSpan<LabelReference>,
        register: RegisterReference,
    },
    RepeatUntil {
        puzzle: PuzzleIdx,
        arch: Arc<Architecture>,
        amts: Vec<(usize, Option<Int<U>>, WithSpan<Int<U>>)>,
        register: RegisterReference,
    },
    Solve {
        puzzle: ByPuzzleType<'static, StateIdx>,
    },
    Input {
        message: WithSpan<String>,
        register: RegisterReference,
    },
    Halt {
        message: WithSpan<String>,
        register: Option<RegisterReference>,
    },
    Print {
        message: WithSpan<String>,
        register: Option<RegisterReference>,
    },
}

/// Autogenerated implementation, modified to do pointer comparison for the `Arc<Architecture>`'s
impl PartialEq for OptimizingPrimitive {
    fn eq(&self, other: &Self) -> bool {
        match (self, other) {
            (
                Self::AddPuzzle {
                    puzzle: l_puzzle,
                    arch: l_arch,
                    amts: l_amts,
                },
                Self::AddPuzzle {
                    puzzle: r_puzzle,
                    arch: r_arch,
                    amts: r_amts,
                },
            ) => {
                l_puzzle == r_puzzle
                    && ptr::eq::<Architecture>(&raw const **l_arch, &raw const **r_arch)
                    && l_amts == r_amts
            }
            (
                Self::AddTheoretical {
                    theoretical: l_theoretical,
                    amt: l_amt,
                },
                Self::AddTheoretical {
                    theoretical: r_theoretical,
                    amt: r_amt,
                },
            ) => l_theoretical == r_theoretical && l_amt == r_amt,
            (Self::Goto { label: l_label }, Self::Goto { label: r_label }) => l_label == r_label,
            (
                Self::SolvedGoto {
                    label: l_label,
                    register: l_register,
                },
                Self::SolvedGoto {
                    label: r_label,
                    register: r_register,
                },
            ) => l_label == r_label && l_register == r_register,
            (
                Self::RepeatUntil {
                    puzzle: l_puzzle,
                    arch: l_arch,
                    amts: l_amts,
                    register: l_register,
                },
                Self::RepeatUntil {
                    puzzle: r_puzzle,
                    arch: r_arch,
                    amts: r_amts,
                    register: r_register,
                },
            ) => {
                let b = &**r_arch;
                l_puzzle == r_puzzle
                    && ptr::eq::<Architecture>(&raw const **l_arch, b)
                    && l_amts == r_amts
                    && l_register == r_register
            }
            (Self::Solve { puzzle: l_puzzle }, Self::Solve { puzzle: r_puzzle }) => {
                l_puzzle == r_puzzle
            }
            (
                Self::Input {
                    message: l_message,
                    register: l_register,
                },
                Self::Input {
                    message: r_message,
                    register: r_register,
                },
            ) => l_message == r_message && l_register == r_register,
            (
                Self::Halt {
                    message: l_message,
                    register: l_register,
                },
                Self::Halt {
                    message: r_message,
                    register: r_register,
                },
            )
            | (
                Self::Print {
                    message: l_message,
                    register: l_register,
                },
                Self::Print {
                    message: r_message,
                    register: r_register,
                },
            ) => l_message == r_message && l_register == r_register,
            _ => false,
        }
    }
}

impl Eq for OptimizingPrimitive {}

#[derive(Clone, Debug, PartialEq, Eq)]
pub enum OptimizingCodeComponent {
    Instruction(Box<OptimizingPrimitive>, BlockID),
    Label(Label),
}

type OneFullPass = (
    RemoveDeadCode,
    (
        Peephole<RemoveUselessJumps>,
        (
            CoalesceAdds,
            (
                Peephole<RepeatUntil1>,
                (
                    Peephole<RepeatUntil2>,
                    (
                        Peephole<RepeatUntil3>,
                        (TransformSolve, Global<DeadLabelRemover>),
                    ),
                ),
            ),
        ),
    ),
);

pub fn do_optimization(
    instructions: impl Iterator<Item = WithSpan<OptimizingCodeComponent>> + 'static,
    global_regs: &Arc<GlobalRegs>,
) -> impl Iterator<Item = WithSpan<OptimizingCodeComponent>> {
    push_to_pull(
        RepeatUntilConvergence::<OneFullPass>::default(),
        instructions,
        Arc::clone(global_regs),
    )
}
