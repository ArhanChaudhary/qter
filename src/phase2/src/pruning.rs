//! A module for representing and constructing pruning tables.
//!
//! At a high level, a pruning tables gives a lower bound on how many
//! moves are needed to solve a given position of the Rubik's Cube. The intention
//! is for these tables to be pre-generated before any solving work begins.
//!
//! Each table is generated by executing an iterative deepening DFS (IDDFS) starting
//! from the solved state. For each state, the depth is recorded in a vector
//! of the appropriate size.

use super::{
    FACT_UNTIL_19,
    puzzle::{PuzzleDef, PuzzleState},
};
use crate::{
    Rebrand, SliceView, SliceViewMut,
    orbit_puzzle::OrbitPuzzleState,
    permutator::pandita2,
    puzzle::{OrbitIdentifier, SortedCycleType, SortedCycleTypeRef},
    start, success, working,
};
use generativity::{Id, make_guard};
use itertools::Itertools;
use log::{debug, info};
use std::{
    marker::PhantomData,
    num::{NonZeroU8, NonZeroUsize},
    time::Instant,
};
use thiserror::Error;

pub trait PruningTables<'id, P: PuzzleState<'id>> {
    type GenerateMetas<'a>
    where
        P: 'a,
        'id: 'a;
    type GenerateError;

    /// Generate pruning tables for a puzzle
    ///
    /// # Errors
    ///
    /// Returns an error if the generation fails
    fn try_generate_all(
        sorted_cycle_type: SortedCycleType<'id>,
        generate_metas: Self::GenerateMetas<'_>,
    ) -> Result<Self, Self::GenerateError>
    where
        Self: Sized;

    /// Get a permissible heuristic for a puzzle state. It is a soundness error
    /// if this is not the case.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;

    /// The pruning table is expected to hold the sorted cycle type so the
    /// instance can be tied to it and not some other foreign cycle type.
    fn sorted_cycle_type_slice_view(&self) -> SortedCycleTypeRef<'id, '_>;
}

/// A trait for a pruning table storage backend
pub trait StorageBackend<const EXACT: bool> {
    type InitializationMeta: UsedSizeBytes;

    /// Initialize the storage backend from an entry count.
    fn initialize_from_meta(initialization_meta: Self::InitializationMeta) -> Self;

    // TODO: almost certainly these signatures need changing. For example adding
    // orbit FSMs as arguments. I've left the API fairly flexible; Henry you can
    // change this however.
    fn initialization_meta_from_entry_count(entry_count: usize) -> Self::InitializationMeta;

    fn initialization_meta_from_max_size_bytes(max_size_bytes: usize) -> Self::InitializationMeta;

    /// Get a **permissible** heuristic from a hash. This is expected to be
    /// implemented as a light wrapper around `heuristic_hash`.
    fn permissible_heuristic_hash(&self, hash: u64) -> u8;

    /// Get a raw heuristic from a hash. The separation is necessary or else
    /// there would otherwise be no way to check if an entry is vacant before
    /// setting it to a value during pruning table generation. A raw getter is
    /// also faster because it avoids the `depth_traversed` overhead with
    /// `permissible_heuristic_hash`.
    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic;

    /// Set the heuristic for a hash.
    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic);

    /// Commit the depth traversed for the pruning table, used to represent the
    /// heuristic for vacant entries.
    fn commit_depth_traversed(&mut self, depth_traversed: u8);
}

/// A pruning table acting on a single orbit.
trait OrbitPruningTable<'id, P: PuzzleState<'id>> {
    /// Generate a pruning table for a target orbit.
    fn try_generate<'a>(
        generate_meta: OrbitPruningTableGenerationMeta<'id, 'a, P>,
    ) -> Result<
        (Self, usize),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<'id, 'a, P>,
        ),
    >
    where
        Self: Sized;

    /// Get a permissible heuristic for a puzzle state for a target orbit. It
    /// is a soundness error if this is not the case. Implementors are expected
    /// to have a mechanism to identify the table's target orbit.
    fn permissible_heuristic(&self, puzzle_state: &P) -> u8;
}

// Not completely sure what this trait should look like; Henry change this if
// you need to for tANS.
pub trait UsedSizeBytes {
    fn used_size_bytes(&self) -> usize;
}

pub struct OrbitPruningTables<'id, P: PuzzleState<'id>> {
    orbit_pruning_tables: Box<[Box<dyn OrbitPruningTable<'id, P> + 'id>]>,
    sorted_cycle_type: SortedCycleType<'id>,
}

#[derive(Debug)]
struct OrbitPruningTableGenerationMeta<'id, 'a, P: PuzzleState<'id>> {
    puzzle_def: &'a PuzzleDef<'id, P>,
    sorted_cycle_type_orbit: &'a [(NonZeroU8, bool)],
    orbit_identifier: P::OrbitIdentifier<'id>,
    max_size_bytes: usize,
}

pub struct OrbitPruningTablesGenerateMeta<'id, 'a, P: PuzzleState<'id>> {
    puzzle_def: &'a PuzzleDef<'id, P>,
    max_size_bytes: usize,
    maybe_table_types: Option<Vec<TableTy>>,
    _id: Id<'id>,
}

pub struct UncompressedStorageBackend<const EXACT: bool> {
    data: Box<[OrbitPruneHeuristic]>,
    depth_traversed: u8,
}

#[allow(unused)]
pub struct NxoptStorageBackend<const EXACT: bool> {
    data: Box<[u8]>,
    base: u8,
}

#[derive(Clone)]
struct TANSStorageEncodingTable {
    // silly things here
}

#[allow(unused)]
pub struct TANSStorageBackend<const EXACT: bool> {
    data: Box<[u8]>,
    counts_by_depth: Box<[u64]>,
    encoding_tables: Box<[TANSStorageEncodingTable]>,
}

pub struct MaxSizeBytes(pub usize);

pub struct TANSDistributionEstimation {
    max_size_bytes: usize,
    // distribution stuff
}

pub struct ApproximateOrbitPruningTable<'id, S: StorageBackend<false>, O: OrbitIdentifier<'id>> {
    storage_backend: S,
    orbit_identifier: O,
    _id: Id<'id>,
}

pub struct ExactOrbitPruningTable<'id, S: StorageBackend<true>, O: OrbitIdentifier<'id>> {
    storage_backend: S,
    orbit_identifier: O,
    _id: Id<'id>,
}

#[allow(unused)]
pub struct CycleTypeOrbitPruningTable<'id, O: OrbitIdentifier<'id>> {
    data: Box<[OrbitPruneHeuristic]>,
    orbit_identifier: O,
    _id: Id<'id>,
}

/// This type isn't actually entirely useless; I will use it for tables that
/// have no remaining allocable space (by the `max_size_bytes` option).
pub struct ZeroOrbitTable;

#[derive(Error, Debug)]
pub enum OrbitPruningTableGenerationError {
    #[error("Orbit pruning table is not large enough to hold all entries")]
    NotBigEnough,
    #[error("Orbit pruning table stores too many entries")]
    TooLargeLoadFactor,
}

#[derive(Error, Debug)]
pub enum TableTypeInstantiationError {
    #[error("Invalid table types length: expected {expected}, actual {actual}")]
    InvalidTableTypesLength { expected: usize, actual: usize },
    #[error("Invalid orbit puzzle types length: expected {expected}, actual {actual}")]
    InvalidOrbitPuzzleTypesLength { expected: usize, actual: usize },
    #[error("Puzzle state cannot be an orbit puzzle")]
    PuzzleStateCannotBeOrbitPuzzle,
}

#[derive(PartialEq, Debug, Clone, Copy)]
pub enum TableTy {
    Approximate(StorageBackendTy),
    Exact(StorageBackendTy),
    CycleTypeUncompressed,
    Zero,
    // We need this so users can specify a vec of table types and make some of
    // them dynamic and some of them not
    Dynamic,
}

#[derive(PartialEq, Debug, Clone, Copy)]
pub enum StorageBackendTy {
    Uncompressed,
    Nxopt,
    Tans,
}

pub struct ZeroTable<'id, P: PuzzleState<'id>> {
    sorted_cycle_type: SortedCycleType<'id>,
    _marker: PhantomData<P>,
}

use private::OrbitPruneHeuristic;
mod private {
    #[derive(Copy, Clone, PartialOrd, Ord, PartialEq, Eq)]
    pub struct OrbitPruneHeuristic(u8);

    impl OrbitPruneHeuristic {
        const VACANT: u8 = u8::MAX;

        pub fn vacant() -> OrbitPruneHeuristic {
            OrbitPruneHeuristic(Self::VACANT)
        }

        pub fn occupied(depth_traversed: u8) -> Option<OrbitPruneHeuristic> {
            if depth_traversed == Self::VACANT {
                None
            } else {
                Some(OrbitPruneHeuristic(depth_traversed))
            }
        }

        pub fn is_vacant(self) -> bool {
            self.0 == Self::VACANT
        }

        pub fn get_occupied(self) -> Option<u8> {
            if self.is_vacant() { None } else { Some(self.0) }
        }
    }
}

impl UsedSizeBytes for MaxSizeBytes {
    fn used_size_bytes(&self) -> usize {
        self.0
    }
}

impl UsedSizeBytes for TANSDistributionEstimation {
    fn used_size_bytes(&self) -> usize {
        self.max_size_bytes
    }
}

impl<'id, 'a, P: PuzzleState<'id>> OrbitPruningTablesGenerateMeta<'id, 'a, P> {
    /// Create a new `OrbitPruningTablesGenerateMeta` with the given parameters.
    #[must_use]
    pub fn new(puzzle_def: &'a PuzzleDef<'id, P>, max_size_bytes: usize, id: Id<'id>) -> Self {
        OrbitPruningTablesGenerateMeta {
            puzzle_def,
            max_size_bytes,
            maybe_table_types: None,
            _id: id,
        }
    }

    /// Create a new `OrbitPruningTablesGenerateMeta` with the given parameters
    ///
    /// # Errors
    ///
    /// Returns an error if the length of `sorted_cycle_type` does not match
    pub fn new_with_table_types(
        puzzle_def: &'a PuzzleDef<'id, P>,
        table_types: Vec<TableTy>,
        max_size_bytes: usize,
        id: Id<'id>,
    ) -> Result<Self, TableTypeInstantiationError> {
        let mut generate_metas = Self::new(puzzle_def, max_size_bytes, id);
        if table_types.len() != puzzle_def.sorted_orbit_defs.len() {
            return Err(TableTypeInstantiationError::InvalidTableTypesLength {
                expected: puzzle_def.sorted_orbit_defs.len(),
                actual: table_types.len(),
            });
        }
        generate_metas.maybe_table_types = Some(table_types);
        Ok(generate_metas)
    }
}

impl<'id, P: PuzzleState<'id> + 'id> PruningTables<'id, P> for OrbitPruningTables<'id, P> {
    type GenerateMetas<'a>
        = OrbitPruningTablesGenerateMeta<'id, 'a, P>
    where
        P: 'a,
        'id: 'a;
    type GenerateError = OrbitPruningTableGenerationError;

    fn try_generate_all(
        sorted_cycle_type: SortedCycleType<'id>,
        generate_metas: OrbitPruningTablesGenerateMeta<'id, '_, P>,
    ) -> Result<OrbitPruningTables<'id, P>, OrbitPruningTableGenerationError> {
        info!(start!("Generating all orbit pruning tables"));
        let start = Instant::now();

        let mut orbit_pruning_tables =
            Vec::with_capacity(generate_metas.puzzle_def.sorted_orbit_defs.len());
        let mut remaining_size_bytes = generate_metas.max_size_bytes;
        // Already sorted by (piece count, orientation) which is (usually) from
        // smallest to largest which makes this work. This essentially populates
        // the smallest pruning tables while dynamically updating how much space
        // is reserved for the remaining orbit tables.
        let mut maybe_orbit_identifier: Option<P::OrbitIdentifier<'id>> = None;
        for (orbit_index, branded_orbit_def) in generate_metas
            .puzzle_def
            .sorted_orbit_defs_slice_view()
            .branded_copied_iter()
            .enumerate()
        {
            maybe_orbit_identifier = Some(if orbit_index == 0 {
                P::OrbitIdentifier::first_orbit_identifier(branded_orbit_def)
            } else {
                maybe_orbit_identifier
                    .unwrap()
                    .next_orbit_identifier(branded_orbit_def)
            });
            let orbit_identifier = maybe_orbit_identifier.unwrap();

            let maybe_table_type = generate_metas
                .maybe_table_types
                .as_ref()
                .map(|table_types| table_types[orbit_index]);

            let sorted_cycle_type_orbit = &sorted_cycle_type.inner[orbit_index];

            // sorted_orbit_defs.len() - orbit_index and then account for zero
            // table types which are manually ignored
            let unprocessed_orbits_count = NonZeroUsize::new(
                generate_metas
                    .puzzle_def
                    .sorted_orbit_defs
                    .len()
                    .checked_sub(orbit_index)
                    .unwrap()
                    .checked_sub(generate_metas.maybe_table_types.as_ref().map_or(
                        0,
                        |table_types| {
                            table_types
                                .iter()
                                .skip(orbit_index)
                                .copied()
                                .filter(|&table_type| matches!(table_type, TableTy::Zero))
                                .count()
                        },
                    ))
                    .unwrap(),
            )
            .unwrap_or_else(|| {
                assert!(matches!(maybe_table_type, Some(TableTy::Zero)));
                NonZeroUsize::new(1).unwrap()
            });

            let max_size_bytes = remaining_size_bytes / unprocessed_orbits_count;

            let generate_meta = OrbitPruningTableGenerationMeta {
                puzzle_def: generate_metas.puzzle_def,
                sorted_cycle_type_orbit,
                orbit_identifier,
                max_size_bytes,
            };

            let (orbit_pruning_table, used_size_bytes) =
                try_generate_orbit_pruning_table_with_table_type(generate_meta, maybe_table_type)?;

            remaining_size_bytes -= used_size_bytes;
            orbit_pruning_tables.push(orbit_pruning_table);
        }

        let orbit_pruning_tables = OrbitPruningTables {
            orbit_pruning_tables: orbit_pruning_tables.into_boxed_slice(),
            sorted_cycle_type,
        };
        info!(
            success!("Generated all orbit pruning tables in {:.3}s"),
            start.elapsed().as_secs_f64()
        );
        debug!("");
        Ok(orbit_pruning_tables)
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.orbit_pruning_tables
            .iter()
            .fold(0, |best_bound, orbit_pruning_table| {
                best_bound.max(orbit_pruning_table.permissible_heuristic(puzzle_state))
            })
    }

    fn sorted_cycle_type_slice_view(&self) -> SortedCycleTypeRef<'id, '_> {
        self.sorted_cycle_type.slice_view()
    }
}

macro_rules! table_fn {
    ($fn_name:ident, $table:ident, $storage:ident, $exact:ident) => {
        fn $fn_name<'id, 'a, P: PuzzleState<'id> + 'id>(
            generate_meta: OrbitPruningTableGenerationMeta<'id, 'a, P>,
        ) -> Result<
            (Box<dyn OrbitPruningTable<'id, P> + 'id>, usize),
            (
                OrbitPruningTableGenerationError,
                OrbitPruningTableGenerationMeta<'id, 'a, P>,
            ),
        > {
            info!(start!("Generating {}"), stringify!($table));
            let start = Instant::now();
            let (table, used_size_bytes) =
                $table::<$storage<{ $exact }>, P::OrbitIdentifier<'id>>::try_generate(
                    generate_meta,
                )?;
            let generated = (
                Box::new(table) as Box<dyn OrbitPruningTable<_>>,
                used_size_bytes,
            );
            info!(
                success!("Generated {} in {:.3}s"),
                stringify!($table),
                start.elapsed().as_secs_f64()
            );
            Ok(generated)
        }
    };
    ($fn_name:ident, $table:ident) => {
        fn $fn_name<'id, 'a, P: PuzzleState<'id> + 'id>(
            generate_meta: OrbitPruningTableGenerationMeta<'id, 'a, P>,
        ) -> Result<
            (Box<dyn OrbitPruningTable<'id, P> + 'id>, usize),
            (
                OrbitPruningTableGenerationError,
                OrbitPruningTableGenerationMeta<'id, 'a, P>,
            ),
        > {
            info!(start!("Generating {}"), stringify!($table));
            let start = Instant::now();
            let (table, used_size_bytes) = $table::try_generate(generate_meta)?;
            let generated = (
                Box::new(table) as Box<dyn OrbitPruningTable<_>>,
                used_size_bytes,
            );
            info!(
                success!("Generated {} in {:.3}s"),
                stringify!($table),
                start.elapsed().as_secs_f64()
            );
            Ok(generated)
        }
    };
}

table_fn! { try_generate_approximate_uncompressed_orbit_table, ApproximateOrbitPruningTable, UncompressedStorageBackend, false }
table_fn! { try_generate_approximate_nxopt_orbit_table,        ApproximateOrbitPruningTable, NxoptStorageBackend,        false }
table_fn! { try_generate_approximate_tans_orbit_table,         ApproximateOrbitPruningTable, TANSStorageBackend,         false }
table_fn! { try_generate_exact_uncompressed_orbit_table,       ExactOrbitPruningTable,       UncompressedStorageBackend, true  }
table_fn! { try_generate_exact_nxopt_orbit_table,              ExactOrbitPruningTable,       NxoptStorageBackend,        true  }
table_fn! { try_generate_exact_tans_orbit_table,               ExactOrbitPruningTable,       TANSStorageBackend,         true  }
table_fn! { try_generate_cycle_type_uncompressed_orbit_table,  CycleTypeOrbitPruningTable                                      }
table_fn! { try_generate_zero_orbit_table,                     ZeroOrbitTable                                                  }

fn try_generate_orbit_pruning_table_with_table_type<'id, P: PuzzleState<'id> + 'id>(
    generate_meta: OrbitPruningTableGenerationMeta<'id, '_, P>,
    table_type: Option<TableTy>,
) -> Result<(Box<dyn OrbitPruningTable<'id, P> + 'id>, usize), OrbitPruningTableGenerationError> {
    match table_type {
        Some(TableTy::Exact(StorageBackendTy::Uncompressed)) => {
            try_generate_exact_uncompressed_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        Some(TableTy::Exact(StorageBackendTy::Nxopt)) => {
            try_generate_exact_nxopt_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        Some(TableTy::Exact(StorageBackendTy::Tans)) => {
            try_generate_exact_tans_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        Some(TableTy::Approximate(StorageBackendTy::Uncompressed)) => {
            try_generate_approximate_uncompressed_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        Some(TableTy::Approximate(StorageBackendTy::Nxopt)) => {
            try_generate_approximate_nxopt_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        Some(TableTy::Approximate(StorageBackendTy::Tans)) => {
            try_generate_approximate_tans_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        Some(TableTy::CycleTypeUncompressed) => {
            try_generate_cycle_type_uncompressed_orbit_table(generate_meta).map_err(|(err, _)| err)
        }
        Some(TableTy::Zero) => Ok(try_generate_zero_orbit_table(generate_meta).unwrap()),
        Some(TableTy::Dynamic) | None => Ok(generate_orbit_pruning_table(generate_meta)),
    }
}

fn generate_orbit_pruning_table<'id, P: PuzzleState<'id> + 'id>(
    mut generate_meta: OrbitPruningTableGenerationMeta<'id, '_, P>,
) -> (Box<dyn OrbitPruningTable<'id, P> + 'id>, usize) {
    for try_table_fn in [
        try_generate_exact_uncompressed_orbit_table,
        try_generate_exact_tans_orbit_table,
        try_generate_approximate_uncompressed_orbit_table,
        try_generate_approximate_tans_orbit_table,
        try_generate_cycle_type_uncompressed_orbit_table,
    ] {
        match try_table_fn(generate_meta) {
            Ok((orbit_pruning_table, used_size_bytes)) => {
                return (orbit_pruning_table, used_size_bytes);
            }
            Err((_, old_generate_meta)) => {
                generate_meta = old_generate_meta;
            }
        }
    }
    try_generate_zero_orbit_table(generate_meta).unwrap()
}

impl<const EXACT: bool> StorageBackend<EXACT> for UncompressedStorageBackend<EXACT> {
    type InitializationMeta = MaxSizeBytes;

    fn initialize_from_meta(initialization_meta: MaxSizeBytes) -> Self {
        let used_size_bytes = initialization_meta.used_size_bytes();
        let data = vec![OrbitPruneHeuristic::vacant(); used_size_bytes].into_boxed_slice();
        UncompressedStorageBackend {
            data,
            depth_traversed: 0,
        }
    }

    fn initialization_meta_from_entry_count(entry_count: usize) -> MaxSizeBytes {
        // Each entry is one byte
        MaxSizeBytes(entry_count)
    }

    fn initialization_meta_from_max_size_bytes(max_size_bytes: usize) -> MaxSizeBytes {
        MaxSizeBytes(max_size_bytes)
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        self.heuristic_hash(hash)
            .get_occupied()
            .unwrap_or(self.depth_traversed)
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        if EXACT {
            #[allow(clippy::cast_possible_truncation)]
            // an exact hash implies (0..self.data.len()).contains(hash) . This
            // also implies that hash is no larger than `self.data.len()` which
            // is a usize. Therefore we can safely cast it to a usize given this
            // condition upheld by the caller.
            self.data[hash as usize]
        } else {
            let hash = hash % self.data.len() as u64;
            #[allow(clippy::cast_possible_truncation)]
            // After the modulus `hash` is guaranteed to be less than
            // `self.data.len()` which is a usize. Therefore we can safely cast
            // it to a usize.
            self.data[hash as usize]
        }
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            #[allow(clippy::cast_possible_truncation)]
            // see above for why this is safe
            let hash = hash as usize;
            self.data[hash] = orbit_prune_heuristic;
        } else {
            let hash = hash % self.data.len() as u64;
            #[allow(clippy::cast_possible_truncation)]
            // see above for why this is safe
            let hash = hash as usize;
            self.data[hash] = self.data[hash].min(orbit_prune_heuristic);
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        self.depth_traversed = depth_traversed;
    }
}

#[allow(unused)]
impl<const EXACT: bool> StorageBackend<EXACT> for NxoptStorageBackend<EXACT> {
    type InitializationMeta = MaxSizeBytes;

    fn initialize_from_meta(initialization_meta: MaxSizeBytes) -> Self {
        let used_size_bytes = initialization_meta.used_size_bytes();
        let data = vec![0; used_size_bytes].into_boxed_slice();
        todo!();
    }

    fn initialization_meta_from_entry_count(entry_count: usize) -> MaxSizeBytes {
        todo!();
    }

    fn initialization_meta_from_max_size_bytes(max_size_bytes: usize) -> MaxSizeBytes {
        todo!();
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        todo!();
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        todo!();
    }
}

#[allow(unused)]
impl<const EXACT: bool> StorageBackend<EXACT> for TANSStorageBackend<EXACT> {
    type InitializationMeta = TANSDistributionEstimation;

    fn initialize_from_meta(initialization_meta: TANSDistributionEstimation) -> Self {
        let used_size_bytes = initialization_meta.used_size_bytes();
        let data = vec![0; used_size_bytes].into_boxed_slice();
        todo!();
    }

    fn initialization_meta_from_entry_count(entry_count: usize) -> TANSDistributionEstimation {
        // experimentation.ipynb stuff
        todo!();
    }

    fn initialization_meta_from_max_size_bytes(
        max_size_bytes: usize,
    ) -> TANSDistributionEstimation {
        TANSDistributionEstimation { max_size_bytes }
    }

    fn permissible_heuristic_hash(&self, hash: u64) -> u8 {
        todo!();
    }

    fn heuristic_hash(&self, hash: u64) -> OrbitPruneHeuristic {
        todo!();
    }

    fn set_heuristic_hash(&mut self, hash: u64, orbit_prune_heuristic: OrbitPruneHeuristic) {
        if EXACT {
            todo!();
        } else {
            todo!();
        }
    }

    fn commit_depth_traversed(&mut self, depth_traversed: u8) {
        todo!();
    }
}

#[allow(unused)]
impl<'id, P: PuzzleState<'id>, S: StorageBackend<false>> OrbitPruningTable<'id, P>
    for ApproximateOrbitPruningTable<'id, S, P::OrbitIdentifier<'id>>
{
    fn try_generate<'a>(
        generate_meta: OrbitPruningTableGenerationMeta<'id, 'a, P>,
    ) -> Result<
        (
            ApproximateOrbitPruningTable<'id, S, P::OrbitIdentifier<'id>>,
            usize,
        ),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<'id, 'a, P>,
        ),
    > {
        // Decide on a load factor to return an err
        todo!();
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.storage_backend
            .permissible_heuristic_hash(fxhash::hash64(
                &puzzle_state.approximate_hash_orbit(self.orbit_identifier),
            ))
    }
}

/// Use Knuth's algorithm M to generate the next orientation vector
/// lexicographically. From: <https://charlesreid1.github.io/lets-generate-permutations.html>
///
/// # Safety
///
/// Each `ori` value must be less than `orientation_count`. This function must
/// not be called more than `(ori.len() - 1).pow(orientation_count.get()) - 1`
/// times.
unsafe fn knuthm(ori: &mut [u8], orientation_count: NonZeroU8) {
    let (last, free) = unsafe { ori.split_last_mut().unwrap_unchecked() };
    let mut j = free.len() - 1;
    while unsafe { *free.get_unchecked(j) } == orientation_count.get() - 1 {
        free[j] = 0;
        *last += 2;
        j -= 1;
    }
    free[j] += 1;
    if free[j] == orientation_count.get() {
        free[j] = 0;
    }
    *last = (*last + 2) % orientation_count.get();
}

impl<'id, P: PuzzleState<'id> + 'id, S: StorageBackend<true>> OrbitPruningTable<'id, P>
    for ExactOrbitPruningTable<'id, S, P::OrbitIdentifier<'id>>
{
    fn try_generate<'a>(
        generate_meta: OrbitPruningTableGenerationMeta<'id, 'a, P>,
    ) -> Result<
        (
            ExactOrbitPruningTable<'id, S, P::OrbitIdentifier<'id>>,
            usize,
        ),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<'id, 'a, P>,
        ),
    > {
        make_guard!(orbit_guard);
        let id = orbit_guard.into();

        let OrbitPruningTableGenerationMeta {
            puzzle_def,
            sorted_cycle_type_orbit,
            orbit_identifier,
            max_size_bytes,
        } = generate_meta;

        let rebranded_orbit_identifier: <<P as PuzzleState<'_>>::OrbitIdentifier<'_> as Rebrand<'_>>::Rebranded<'_> = orbit_identifier.rebrand(id);

        let orbit_puzzle = P::pick_orbit_puzzle(rebranded_orbit_identifier);

        let branded_orbit_def = rebranded_orbit_identifier.branded_orbit_def();
        // TODO: make this common for all pruning tables
        let piece_count = branded_orbit_def.inner.piece_count.get();

        let orientation_count = u64::pow(
            u64::from(branded_orbit_def.inner.orientation_count.get()),
            u32::from(piece_count) - 1,
        );
        let entry_count = FACT_UNTIL_19[piece_count as usize] * orientation_count;
        let initialization_meta =
            S::initialization_meta_from_entry_count(entry_count.try_into().unwrap());
        let used_size_bytes = initialization_meta.used_size_bytes();
        if used_size_bytes > max_size_bytes {
            return Err((
                OrbitPruningTableGenerationError::NotBigEnough,
                generate_meta,
            ));
        }
        let mut table = ExactOrbitPruningTable {
            storage_backend: S::initialize_from_meta(initialization_meta),
            orbit_identifier,
            _id: puzzle_def.id(),
        };

        let puzzle_solved = puzzle_def.new_solved_state();
        let (perm, ori) = puzzle_solved.orbit_bytes(orbit_identifier);
        let orbit_solved =
            orbit_puzzle.from_orbit_transformation_unchecked(perm, ori, branded_orbit_def);

        let orbit_move_class_indicies = puzzle_def
            .move_classes
            .iter()
            .copied()
            .enumerate()
            .filter_map(|(i, move_class)| {
                let (perm, ori) = puzzle_def.moves[move_class]
                    .puzzle_state()
                    .orbit_bytes(orbit_identifier);
                if orbit_puzzle.from_orbit_transformation_unchecked(perm, ori, branded_orbit_def)
                    == orbit_solved
                {
                    None
                } else {
                    Some(i)
                }
            })
            .collect_vec();

        let orbit_moves = puzzle_def
            .moves
            .iter()
            .filter_map(|move_| {
                if orbit_move_class_indicies.contains(&move_.move_class_index()) {
                    let (perm, ori) = move_.puzzle_state().orbit_bytes(orbit_identifier);
                    Some(orbit_puzzle.from_orbit_transformation_unchecked(
                        perm,
                        ori,
                        branded_orbit_def,
                    ))
                } else {
                    None
                }
            })
            .collect_vec();

        let mut orbit_result = orbit_solved.clone();

        let mut aux_mem = P::new_aux_mem(puzzle_def.sorted_orbit_defs_slice_view()).rebrand(id);
        let mut depth = 0;
        let mut vacant_entry_count = entry_count;

        // TODO: multithreading
        // TODO: replace first few with IDDFS
        let mut perm = (0..piece_count).collect_vec().into_boxed_slice();
        let mut ori = vec![0; piece_count as usize].into_boxed_slice();
        while let Some(depth_heuristic) = OrbitPruneHeuristic::occupied(depth) {
            let depth_start = Instant::now();
            let prev_vacant_entry_count = vacant_entry_count;
            let mut exact_orbit_hash = 0;
            for i in 0..piece_count {
                perm[i as usize] = i;
            }
            while exact_orbit_hash < entry_count {
                ori.fill(0);
                let mut first = true;
                loop {
                    if first {
                        first = false;
                    } else {
                        if exact_orbit_hash % orientation_count == 0 {
                            break;
                        }
                        unsafe {
                            knuthm(&mut ori, branded_orbit_def.inner.orientation_count);
                        }
                    }
                    if depth != 0
                        && table
                            .storage_backend
                            .heuristic_hash(exact_orbit_hash)
                            .get_occupied()
                            != Some(depth - 1)
                    {
                        exact_orbit_hash += 1;
                        continue;
                    }

                    let curr_state = orbit_solved.from_orbit_transformation_unchecked(
                        &perm,
                        &ori,
                        branded_orbit_def,
                    );
                    if depth == 0 {
                        if curr_state.induces_sorted_cycle_type(
                            sorted_cycle_type_orbit,
                            branded_orbit_def,
                            aux_mem.slice_view_mut(),
                        ) {
                            table
                                .storage_backend
                                .set_heuristic_hash(exact_orbit_hash, depth_heuristic);
                            vacant_entry_count -= 1;
                        }
                        exact_orbit_hash += 1;
                        continue;
                    }

                    for move_ in &orbit_moves {
                        unsafe {
                            orbit_result.replace_compose(&curr_state, move_, branded_orbit_def)
                        };
                        let new_hash = orbit_result.exact_hasher(branded_orbit_def);
                        if table.storage_backend.heuristic_hash(new_hash).is_vacant() {
                            table
                                .storage_backend
                                .set_heuristic_hash(new_hash, depth_heuristic);
                            vacant_entry_count -= 1;
                        }
                    }
                    exact_orbit_hash += 1;
                }
                unsafe {
                    pandita2(&mut perm);
                }
            }
            debug!(
                working!("Filled {} entries in {:.3}s"),
                prev_vacant_entry_count - vacant_entry_count,
                depth_start.elapsed().as_secs_f64()
            );
            debug!(
                working!("Pruning table depth {}: {}/{}"),
                depth,
                entry_count - vacant_entry_count,
                entry_count,
            );
            if vacant_entry_count == 0 {
                assert_eq!(exact_orbit_hash, entry_count);
                break;
            }
            depth += 1;
        }
        Ok((table, used_size_bytes))
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        self.storage_backend
            .permissible_heuristic_hash(puzzle_state.exact_hasher_orbit(self.orbit_identifier))
    }
}

#[allow(unused)]
impl<'id, P: PuzzleState<'id>> OrbitPruningTable<'id, P>
    for CycleTypeOrbitPruningTable<'id, P::OrbitIdentifier<'id>>
{
    fn try_generate<'a>(
        generate_meta: OrbitPruningTableGenerationMeta<'id, 'a, P>,
    ) -> Result<
        (
            CycleTypeOrbitPruningTable<'id, P::OrbitIdentifier<'id>>,
            usize,
        ),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<'id, 'a, P>,
        ),
    > {
        todo!();
    }

    fn permissible_heuristic(&self, puzzle_state: &P) -> u8 {
        let hash = todo!();
    }
}

impl<'id, P: PuzzleState<'id>> OrbitPruningTable<'id, P> for ZeroOrbitTable {
    fn try_generate<'a>(
        _generate_meta: OrbitPruningTableGenerationMeta<'id, 'a, P>,
    ) -> Result<
        (ZeroOrbitTable, usize),
        (
            OrbitPruningTableGenerationError,
            OrbitPruningTableGenerationMeta<'id, 'a, P>,
        ),
    > {
        Ok((ZeroOrbitTable, 0))
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }
}

impl<'id, P: PuzzleState<'id>> PruningTables<'id, P> for ZeroTable<'id, P> {
    type GenerateMetas<'a>
        = ()
    where
        P: 'a,
        'id: 'a;
    type GenerateError = ();

    fn try_generate_all(
        sorted_cycle_type: SortedCycleType<'id>,
        (): (),
    ) -> Result<ZeroTable<'id, P>, ()> {
        info!(success!("Generated no pruning table"));
        debug!("");
        Ok(ZeroTable {
            sorted_cycle_type,
            _marker: PhantomData,
        })
    }

    fn permissible_heuristic(&self, _puzzle_state: &P) -> u8 {
        0
    }

    fn sorted_cycle_type_slice_view(&self) -> SortedCycleTypeRef<'id, '_> {
        self.sorted_cycle_type.slice_view()
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::puzzle::{apply_random_moves, cube3::Cube3};
    use generativity::make_guard;
    use puzzle_geometry::ksolve::KPUZZLE_3X3;

    #[test_log::test]
    fn test_orbit_prune_heuristic_invariants() {
        let vacant = OrbitPruneHeuristic::vacant();
        assert!(vacant.is_vacant());
        assert_eq!(vacant.get_occupied(), None);

        let occupied = OrbitPruneHeuristic::occupied(5).unwrap();
        assert!(!occupied.is_vacant());
        assert_eq!(occupied.get_occupied(), Some(5));

        let occupied = OrbitPruneHeuristic::occupied(255);
        assert!(occupied.is_none());
    }

    #[test_log::test]
    fn test_exact_uncompressed_storage_backend() {
        let mut storage =
            UncompressedStorageBackend::<true>::initialize_from_meta(MaxSizeBytes(100));

        storage.set_heuristic_hash(5, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(5), 3);

        assert_eq!(storage.permissible_heuristic_hash(6), 0);
        storage.commit_depth_traversed(4);
        assert_eq!(storage.permissible_heuristic_hash(6), 4);
        assert_eq!(storage.permissible_heuristic_hash(5), 3);
    }

    #[test_log::test]
    fn test_approximate_uncompressed_storage_backend() {
        let mut storage =
            UncompressedStorageBackend::<false>::initialize_from_meta(MaxSizeBytes(100));

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(3).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 3);

        storage.set_heuristic_hash(6, OrbitPruneHeuristic::occupied(2).unwrap());
        assert_eq!(storage.permissible_heuristic_hash(6), 2);
    }

    #[test_log::test]
    fn test_zero_orbit_tables() {
        make_guard!(guard);
        let cube3_def = PuzzleDef::<Cube3>::new(&KPUZZLE_3X3, guard).unwrap();
        let solved = cube3_def.new_solved_state();
        let u_move = cube3_def.find_move("U").unwrap();
        let identity_cycle_type =
            SortedCycleType::new(&[vec![], vec![]], cube3_def.sorted_orbit_defs_slice_view())
                .unwrap();

        let generate_meta = OrbitPruningTableGenerationMeta {
            puzzle_def: &cube3_def,
            sorted_cycle_type_orbit: &[],
            orbit_identifier: <Cube3 as PuzzleState>::OrbitIdentifier::first_orbit_identifier(
                cube3_def
                    .sorted_orbit_defs_slice_view()
                    .branded_copied_iter()
                    .next()
                    .unwrap(),
            ),
            max_size_bytes: 0,
        };
        let (zero_orbit_table, _) = ZeroOrbitTable::try_generate(generate_meta).unwrap();
        assert_eq!(zero_orbit_table.permissible_heuristic(&solved), 0);
        assert_eq!(
            zero_orbit_table.permissible_heuristic(u_move.puzzle_state()),
            0
        );

        let generate_metas = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            vec![TableTy::Zero, TableTy::Zero],
            0,
            cube3_def.id(),
        )
        .unwrap();
        let orbit_tables =
            OrbitPruningTables::try_generate_all(identity_cycle_type, generate_metas).unwrap();

        assert_eq!(orbit_tables.permissible_heuristic(&solved), 0);
        assert_eq!(orbit_tables.permissible_heuristic(u_move.puzzle_state()), 0);
    }

    #[test_log::test]
    fn test_zero_table() {
        make_guard!(guard);
        let cube3_def = PuzzleDef::<Cube3>::new(&KPUZZLE_3X3, guard).unwrap();
        let identity_cycle_type =
            SortedCycleType::new(&[vec![], vec![]], cube3_def.sorted_orbit_defs_slice_view())
                .unwrap();
        let zero_table = ZeroTable::try_generate_all(identity_cycle_type, ()).unwrap();

        let random_state = apply_random_moves(&cube3_def, &cube3_def.new_solved_state(), 20);
        assert_eq!(zero_table.permissible_heuristic(&random_state), 0);
    }

    #[test]
    fn test_new_orbit_generation_meta() {
        make_guard!(guard);
        let cube3_def = PuzzleDef::<Cube3>::new(&KPUZZLE_3X3, guard).unwrap();
        let id = cube3_def.id();
        let generate_metas = OrbitPruningTablesGenerateMeta::new(&cube3_def, 1000, id);
        assert_eq!(generate_metas.max_size_bytes, 1000);
        assert!(generate_metas.maybe_table_types.is_none());

        assert!(matches!(
            OrbitPruningTablesGenerateMeta::new_with_table_types(
                &cube3_def,
                vec![TableTy::Exact(StorageBackendTy::Uncompressed)],
                1000,
                id,
            ),
            Err(TableTypeInstantiationError::InvalidTableTypesLength {
                expected: _,
                actual: _
            })
        ));

        OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            vec![
                TableTy::Exact(StorageBackendTy::Uncompressed),
                TableTy::Exact(StorageBackendTy::Uncompressed),
            ],
            1000,
            id,
        )
        .unwrap();
    }

    #[test]
    fn test_max_bytes_cannot_be_generated() {
        make_guard!(guard);
        let cube3_def = PuzzleDef::<Cube3>::new(&KPUZZLE_3X3, guard).unwrap();
        let id = cube3_def.id();
        let identity_cycle_type =
            SortedCycleType::new(&[vec![], vec![]], cube3_def.sorted_orbit_defs_slice_view())
                .unwrap();
        let generate_metas = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            vec![
                TableTy::Exact(StorageBackendTy::Uncompressed),
                TableTy::Zero,
            ],
            88_179_839,
            id,
        )
        .unwrap();

        let orbit_tables =
            OrbitPruningTables::try_generate_all(identity_cycle_type, generate_metas);
        assert!(matches!(
            orbit_tables,
            Err(OrbitPruningTableGenerationError::NotBigEnough)
        ));
    }

    #[test]
    fn test_knuthm() {
        let piece_count = 4;
        let mut ori = vec![0; piece_count];
        for i in 0..26 {
            unsafe { knuthm(&mut ori, NonZeroU8::new(3).unwrap()) };
            assert_eq!(
                ori,
                [
                    [0, 0, 1, 2],
                    [0, 0, 2, 1],
                    [0, 1, 0, 2],
                    [0, 1, 1, 1],
                    [0, 1, 2, 0],
                    [0, 2, 0, 1],
                    [0, 2, 1, 0],
                    [0, 2, 2, 2],
                    [1, 0, 0, 2],
                    [1, 0, 1, 1],
                    [1, 0, 2, 0],
                    [1, 1, 0, 1],
                    [1, 1, 1, 0],
                    [1, 1, 2, 2],
                    [1, 2, 0, 0],
                    [1, 2, 1, 2],
                    [1, 2, 2, 1],
                    [2, 0, 0, 1],
                    [2, 0, 1, 0],
                    [2, 0, 2, 2],
                    [2, 1, 0, 0],
                    [2, 1, 1, 2],
                    [2, 1, 2, 1],
                    [2, 2, 0, 2],
                    [2, 2, 1, 1],
                    [2, 2, 2, 0]
                ][i]
            );
        }
    }

    #[test_log::test]
    fn test_wip() {
        return;
        make_guard!(guard);
        let cube3_def = PuzzleDef::<Cube3>::new(&KPUZZLE_3X3, guard).unwrap();
        let id = cube3_def.id();
        let identity_cycle_type =
            SortedCycleType::new(&[vec![], vec![]], cube3_def.sorted_orbit_defs_slice_view())
                .unwrap();
        let generate_metas = OrbitPruningTablesGenerateMeta::new_with_table_types(
            &cube3_def,
            vec![
                TableTy::Exact(StorageBackendTy::Uncompressed),
                TableTy::Zero,
            ],
            88_179_840,
            id,
        )
        .unwrap();
        let orbit_tables =
            OrbitPruningTables::try_generate_all(identity_cycle_type, generate_metas).unwrap();
        assert_eq!(orbit_tables.orbit_pruning_tables.len(), 2);
        assert_eq!(
            orbit_tables.orbit_pruning_tables[0]
                .permissible_heuristic(&cube3_def.new_solved_state()),
            0
        );
        panic!();
        // println!(
        //     "{:?}",
        //     orbit_tables.orbit_pruning_tables[1]
        // )
        // write the bytes of orbit_tables.orbit_pruning_tables[0] to a file
        // use std::fs::File;
        // let mut file = File::create("orbit_tables.bin").unwrap();
        // // bincode::serialize_into(&mut file, &orbit_tables).unwrap();
        // bincode::encode_to_vec(
        //     &orbit_tables.orbit_pruning_tables[0],
        //     bincode::config::standard(),
        // )
        // .unwrap();
        // // write variable to file
        // let mut file = File::create("orbit_tables.bin").unwrap();
        // bincode::serialize_into(&mut file, &orbit_tables).unwrap();
        // // read variable from file
        // let mut file = File::open("orbit_tables.bin").unwrap();
        // let orbit_tables: OrbitPruningTables<Cube3> =
        //     bincode::deserialize_from(&mut file).unwrap();
    }
    // #[test_log::test]
    // fn test_exact_orbit_hasher_only_hashes_orbit() {
    //     let cube3_def = PuzzleDef::<Cube3>::new(&KPUZZLE_3X3, guard).unwrap();
    //     let solved = cube3_def.new_solved_state();
    //     let mut result_1 = solved.clone();
    //     let mut result_2 = solved.clone();
    //     let u_move = cube3_def.find_move("U").unwrap();

    //     let exact_corners_pruning_table =
    //         ExactOrbitPruningTable::<UncompressedStorageBackend<true>> {
    //             storage_backend: UncompressedStorageBackend::initialize_from_meta(MaxEntries(100)),
    //             orbit_def: cube3_def.sorted_orbit_defs[0],
    //             orbit_identifier: 0,
    //         };

    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&solved), 0);
    //     result_1.replace_compose(&solved, &u_move.puzzle_state, &cube3_def.sorted_orbit_defs);
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         24476904
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         57868020
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         67775130
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_2), 0);

    //     // shortest 11 cycle alg
    //     result_1 = apply_moves(&cube3_def, &solved, "U R U F L R' U' R' F' D'", 1);

    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         24476904
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_1),
    //         57868020
    //     );
    //     result_2.replace_compose(
    //         &result_1,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(
    //         exact_corners_pruning_table.hash_orbit_state(&result_2),
    //         67775130
    //     );
    //     result_1.replace_compose(
    //         &result_2,
    //         &u_move.puzzle_state,
    //         &cube3_def.sorted_orbit_defs,
    //     );
    //     assert_eq!(exact_corners_pruning_table.hash_orbit_state(&result_1), 0);

    //     assert_ne!(solved, result_1);
    // }
}
